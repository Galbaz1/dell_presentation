/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./node_modules/gsap/dist/MotionPathPlugin.js":
/*!****************************************************!*\
  !*** ./node_modules/gsap/dist/MotionPathPlugin.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (global, factory) {\n\t true ? factory(exports) :\n\t0;\n}(this, (function (exports) { 'use strict';\n\n\tvar _svgPathExp = /[achlmqstvz]|(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig,\n\t    _numbersExp = /(?:(-)?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig,\n\t    _scientific = /[\\+\\-]?\\d*\\.?\\d+e[\\+\\-]?\\d+/ig,\n\t    _selectorExp = /(^[#\\.][a-z]|[a-y][a-z])/i,\n\t    _DEG2RAD = Math.PI / 180,\n\t    _RAD2DEG = 180 / Math.PI,\n\t    _sin = Math.sin,\n\t    _cos = Math.cos,\n\t    _abs = Math.abs,\n\t    _sqrt = Math.sqrt,\n\t    _atan2 = Math.atan2,\n\t    _largeNum = 1e8,\n\t    _isString = function _isString(value) {\n\t  return typeof value === \"string\";\n\t},\n\t    _isNumber = function _isNumber(value) {\n\t  return typeof value === \"number\";\n\t},\n\t    _isUndefined = function _isUndefined(value) {\n\t  return typeof value === \"undefined\";\n\t},\n\t    _temp = {},\n\t    _temp2 = {},\n\t    _roundingNum = 1e5,\n\t    _wrapProgress = function _wrapProgress(progress) {\n\t  return Math.round((progress + _largeNum) % 1 * _roundingNum) / _roundingNum || (progress < 0 ? 0 : 1);\n\t},\n\t    _round = function _round(value) {\n\t  return Math.round(value * _roundingNum) / _roundingNum || 0;\n\t},\n\t    _roundPrecise = function _roundPrecise(value) {\n\t  return Math.round(value * 1e10) / 1e10 || 0;\n\t},\n\t    _splitSegment = function _splitSegment(rawPath, segIndex, i, t) {\n\t  var segment = rawPath[segIndex],\n\t      shift = t === 1 ? 6 : subdivideSegment(segment, i, t);\n\n\t  if ((shift || !t) && shift + i + 2 < segment.length) {\n\t    rawPath.splice(segIndex, 0, segment.slice(0, i + shift + 2));\n\t    segment.splice(0, i + shift);\n\t    return 1;\n\t  }\n\t},\n\t    _getSampleIndex = function _getSampleIndex(samples, length, progress) {\n\t  var l = samples.length,\n\t      i = ~~(progress * l);\n\n\t  if (samples[i] > length) {\n\t    while (--i && samples[i] > length) {}\n\n\t    i < 0 && (i = 0);\n\t  } else {\n\t    while (samples[++i] < length && i < l) {}\n\t  }\n\n\t  return i < l ? i : l - 1;\n\t},\n\t    _reverseRawPath = function _reverseRawPath(rawPath, skipOuter) {\n\t  var i = rawPath.length;\n\t  skipOuter || rawPath.reverse();\n\n\t  while (i--) {\n\t    rawPath[i].reversed || reverseSegment(rawPath[i]);\n\t  }\n\t},\n\t    _copyMetaData = function _copyMetaData(source, copy) {\n\t  copy.totalLength = source.totalLength;\n\n\t  if (source.samples) {\n\t    copy.samples = source.samples.slice(0);\n\t    copy.lookup = source.lookup.slice(0);\n\t    copy.minLength = source.minLength;\n\t    copy.resolution = source.resolution;\n\t  } else if (source.totalPoints) {\n\t    copy.totalPoints = source.totalPoints;\n\t  }\n\n\t  return copy;\n\t},\n\t    _appendOrMerge = function _appendOrMerge(rawPath, segment) {\n\t  var index = rawPath.length,\n\t      prevSeg = rawPath[index - 1] || [],\n\t      l = prevSeg.length;\n\n\t  if (index && segment[0] === prevSeg[l - 2] && segment[1] === prevSeg[l - 1]) {\n\t    segment = prevSeg.concat(segment.slice(2));\n\t    index--;\n\t  }\n\n\t  rawPath[index] = segment;\n\t};\n\n\tfunction getRawPath(value) {\n\t  value = _isString(value) && _selectorExp.test(value) ? document.querySelector(value) || value : value;\n\t  var e = value.getAttribute ? value : 0,\n\t      rawPath;\n\n\t  if (e && (value = value.getAttribute(\"d\"))) {\n\t    if (!e._gsPath) {\n\t      e._gsPath = {};\n\t    }\n\n\t    rawPath = e._gsPath[value];\n\t    return rawPath && !rawPath._dirty ? rawPath : e._gsPath[value] = stringToRawPath(value);\n\t  }\n\n\t  return !value ? console.warn(\"Expecting a <path> element or an SVG path data string\") : _isString(value) ? stringToRawPath(value) : _isNumber(value[0]) ? [value] : value;\n\t}\n\tfunction copyRawPath(rawPath) {\n\t  var a = [],\n\t      i = 0;\n\n\t  for (; i < rawPath.length; i++) {\n\t    a[i] = _copyMetaData(rawPath[i], rawPath[i].slice(0));\n\t  }\n\n\t  return _copyMetaData(rawPath, a);\n\t}\n\tfunction reverseSegment(segment) {\n\t  var i = 0,\n\t      y;\n\t  segment.reverse();\n\n\t  for (; i < segment.length; i += 2) {\n\t    y = segment[i];\n\t    segment[i] = segment[i + 1];\n\t    segment[i + 1] = y;\n\t  }\n\n\t  segment.reversed = !segment.reversed;\n\t}\n\n\tvar _createPath = function _createPath(e, ignore) {\n\t  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\"),\n\t      attr = [].slice.call(e.attributes),\n\t      i = attr.length,\n\t      name;\n\t  ignore = \",\" + ignore + \",\";\n\n\t  while (--i > -1) {\n\t    name = attr[i].nodeName.toLowerCase();\n\n\t    if (ignore.indexOf(\",\" + name + \",\") < 0) {\n\t      path.setAttributeNS(null, name, attr[i].nodeValue);\n\t    }\n\t  }\n\n\t  return path;\n\t},\n\t    _typeAttrs = {\n\t  rect: \"rx,ry,x,y,width,height\",\n\t  circle: \"r,cx,cy\",\n\t  ellipse: \"rx,ry,cx,cy\",\n\t  line: \"x1,x2,y1,y2\"\n\t},\n\t    _attrToObj = function _attrToObj(e, attrs) {\n\t  var props = attrs ? attrs.split(\",\") : [],\n\t      obj = {},\n\t      i = props.length;\n\n\t  while (--i > -1) {\n\t    obj[props[i]] = +e.getAttribute(props[i]) || 0;\n\t  }\n\n\t  return obj;\n\t};\n\n\tfunction convertToPath(element, swap) {\n\t  var type = element.tagName.toLowerCase(),\n\t      circ = 0.552284749831,\n\t      data,\n\t      x,\n\t      y,\n\t      r,\n\t      ry,\n\t      path,\n\t      rcirc,\n\t      rycirc,\n\t      points,\n\t      w,\n\t      h,\n\t      x2,\n\t      x3,\n\t      x4,\n\t      x5,\n\t      x6,\n\t      y2,\n\t      y3,\n\t      y4,\n\t      y5,\n\t      y6,\n\t      attr;\n\n\t  if (type === \"path\" || !element.getBBox) {\n\t    return element;\n\t  }\n\n\t  path = _createPath(element, \"x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points\");\n\t  attr = _attrToObj(element, _typeAttrs[type]);\n\n\t  if (type === \"rect\") {\n\t    r = attr.rx;\n\t    ry = attr.ry || r;\n\t    x = attr.x;\n\t    y = attr.y;\n\t    w = attr.width - r * 2;\n\t    h = attr.height - ry * 2;\n\n\t    if (r || ry) {\n\t      x2 = x + r * (1 - circ);\n\t      x3 = x + r;\n\t      x4 = x3 + w;\n\t      x5 = x4 + r * circ;\n\t      x6 = x4 + r;\n\t      y2 = y + ry * (1 - circ);\n\t      y3 = y + ry;\n\t      y4 = y3 + h;\n\t      y5 = y4 + ry * circ;\n\t      y6 = y4 + ry;\n\t      data = \"M\" + x6 + \",\" + y3 + \" V\" + y4 + \" C\" + [x6, y5, x5, y6, x4, y6, x4 - (x4 - x3) / 3, y6, x3 + (x4 - x3) / 3, y6, x3, y6, x2, y6, x, y5, x, y4, x, y4 - (y4 - y3) / 3, x, y3 + (y4 - y3) / 3, x, y3, x, y2, x2, y, x3, y, x3 + (x4 - x3) / 3, y, x4 - (x4 - x3) / 3, y, x4, y, x5, y, x6, y2, x6, y3].join(\",\") + \"z\";\n\t    } else {\n\t      data = \"M\" + (x + w) + \",\" + y + \" v\" + h + \" h\" + -w + \" v\" + -h + \" h\" + w + \"z\";\n\t    }\n\t  } else if (type === \"circle\" || type === \"ellipse\") {\n\t    if (type === \"circle\") {\n\t      r = ry = attr.r;\n\t      rycirc = r * circ;\n\t    } else {\n\t      r = attr.rx;\n\t      ry = attr.ry;\n\t      rycirc = ry * circ;\n\t    }\n\n\t    x = attr.cx;\n\t    y = attr.cy;\n\t    rcirc = r * circ;\n\t    data = \"M\" + (x + r) + \",\" + y + \" C\" + [x + r, y + rycirc, x + rcirc, y + ry, x, y + ry, x - rcirc, y + ry, x - r, y + rycirc, x - r, y, x - r, y - rycirc, x - rcirc, y - ry, x, y - ry, x + rcirc, y - ry, x + r, y - rycirc, x + r, y].join(\",\") + \"z\";\n\t  } else if (type === \"line\") {\n\t    data = \"M\" + attr.x1 + \",\" + attr.y1 + \" L\" + attr.x2 + \",\" + attr.y2;\n\t  } else if (type === \"polyline\" || type === \"polygon\") {\n\t    points = (element.getAttribute(\"points\") + \"\").match(_numbersExp) || [];\n\t    x = points.shift();\n\t    y = points.shift();\n\t    data = \"M\" + x + \",\" + y + \" L\" + points.join(\",\");\n\n\t    if (type === \"polygon\") {\n\t      data += \",\" + x + \",\" + y + \"z\";\n\t    }\n\t  }\n\n\t  path.setAttribute(\"d\", rawPathToString(path._gsRawPath = stringToRawPath(data)));\n\n\t  if (swap && element.parentNode) {\n\t    element.parentNode.insertBefore(path, element);\n\t    element.parentNode.removeChild(element);\n\t  }\n\n\t  return path;\n\t}\n\n\tfunction getRotationAtBezierT(segment, i, t) {\n\t  var a = segment[i],\n\t      b = segment[i + 2],\n\t      c = segment[i + 4],\n\t      x;\n\t  a += (b - a) * t;\n\t  b += (c - b) * t;\n\t  a += (b - a) * t;\n\t  x = b + (c + (segment[i + 6] - c) * t - b) * t - a;\n\t  a = segment[i + 1];\n\t  b = segment[i + 3];\n\t  c = segment[i + 5];\n\t  a += (b - a) * t;\n\t  b += (c - b) * t;\n\t  a += (b - a) * t;\n\t  return _round(_atan2(b + (c + (segment[i + 7] - c) * t - b) * t - a, x) * _RAD2DEG);\n\t}\n\n\tfunction sliceRawPath(rawPath, start, end) {\n\t  end = _isUndefined(end) ? 1 : _roundPrecise(end) || 0;\n\t  start = _roundPrecise(start) || 0;\n\t  var loops = Math.max(0, ~~(_abs(end - start) - 1e-8)),\n\t      path = copyRawPath(rawPath);\n\n\t  if (start > end) {\n\t    start = 1 - start;\n\t    end = 1 - end;\n\n\t    _reverseRawPath(path);\n\n\t    path.totalLength = 0;\n\t  }\n\n\t  if (start < 0 || end < 0) {\n\t    var offset = Math.abs(~~Math.min(start, end)) + 1;\n\t    start += offset;\n\t    end += offset;\n\t  }\n\n\t  path.totalLength || cacheRawPathMeasurements(path);\n\t  var wrap = end > 1,\n\t      s = getProgressData(path, start, _temp, true),\n\t      e = getProgressData(path, end, _temp2),\n\t      eSeg = e.segment,\n\t      sSeg = s.segment,\n\t      eSegIndex = e.segIndex,\n\t      sSegIndex = s.segIndex,\n\t      ei = e.i,\n\t      si = s.i,\n\t      sameSegment = sSegIndex === eSegIndex,\n\t      sameBezier = ei === si && sameSegment,\n\t      wrapsBehind,\n\t      sShift,\n\t      eShift,\n\t      i,\n\t      copy,\n\t      totalSegments,\n\t      l,\n\t      j;\n\n\t  if (wrap || loops) {\n\t    wrapsBehind = eSegIndex < sSegIndex || sameSegment && ei < si || sameBezier && e.t < s.t;\n\n\t    if (_splitSegment(path, sSegIndex, si, s.t)) {\n\t      sSegIndex++;\n\n\t      if (!wrapsBehind) {\n\t        eSegIndex++;\n\n\t        if (sameBezier) {\n\t          e.t = (e.t - s.t) / (1 - s.t);\n\t          ei = 0;\n\t        } else if (sameSegment) {\n\t          ei -= si;\n\t        }\n\t      }\n\t    }\n\n\t    if (Math.abs(1 - (end - start)) < 1e-5) {\n\t      eSegIndex = sSegIndex - 1;\n\t    } else if (!e.t && eSegIndex) {\n\t      eSegIndex--;\n\t    } else if (_splitSegment(path, eSegIndex, ei, e.t) && wrapsBehind) {\n\t      sSegIndex++;\n\t    }\n\n\t    if (s.t === 1) {\n\t      sSegIndex = (sSegIndex + 1) % path.length;\n\t    }\n\n\t    copy = [];\n\t    totalSegments = path.length;\n\t    l = 1 + totalSegments * loops;\n\t    j = sSegIndex;\n\t    l += (totalSegments - sSegIndex + eSegIndex) % totalSegments;\n\n\t    for (i = 0; i < l; i++) {\n\t      _appendOrMerge(copy, path[j++ % totalSegments]);\n\t    }\n\n\t    path = copy;\n\t  } else {\n\t    eShift = e.t === 1 ? 6 : subdivideSegment(eSeg, ei, e.t);\n\n\t    if (start !== end) {\n\t      sShift = subdivideSegment(sSeg, si, sameBezier ? s.t / e.t : s.t);\n\t      sameSegment && (eShift += sShift);\n\t      eSeg.splice(ei + eShift + 2);\n\t      (sShift || si) && sSeg.splice(0, si + sShift);\n\t      i = path.length;\n\n\t      while (i--) {\n\t        (i < sSegIndex || i > eSegIndex) && path.splice(i, 1);\n\t      }\n\t    } else {\n\t      eSeg.angle = getRotationAtBezierT(eSeg, ei + eShift, 0);\n\t      ei += eShift;\n\t      s = eSeg[ei];\n\t      e = eSeg[ei + 1];\n\t      eSeg.length = eSeg.totalLength = 0;\n\t      eSeg.totalPoints = path.totalPoints = 8;\n\t      eSeg.push(s, e, s, e, s, e, s, e);\n\t    }\n\t  }\n\n\t  path.totalLength = 0;\n\t  return path;\n\t}\n\n\tfunction measureSegment(segment, startIndex, bezierQty) {\n\t  startIndex = startIndex || 0;\n\n\t  if (!segment.samples) {\n\t    segment.samples = [];\n\t    segment.lookup = [];\n\t  }\n\n\t  var resolution = ~~segment.resolution || 12,\n\t      inc = 1 / resolution,\n\t      endIndex = bezierQty ? startIndex + bezierQty * 6 + 1 : segment.length,\n\t      x1 = segment[startIndex],\n\t      y1 = segment[startIndex + 1],\n\t      samplesIndex = startIndex ? startIndex / 6 * resolution : 0,\n\t      samples = segment.samples,\n\t      lookup = segment.lookup,\n\t      min = (startIndex ? segment.minLength : _largeNum) || _largeNum,\n\t      prevLength = samples[samplesIndex + bezierQty * resolution - 1],\n\t      length = startIndex ? samples[samplesIndex - 1] : 0,\n\t      i,\n\t      j,\n\t      x4,\n\t      x3,\n\t      x2,\n\t      xd,\n\t      xd1,\n\t      y4,\n\t      y3,\n\t      y2,\n\t      yd,\n\t      yd1,\n\t      inv,\n\t      t,\n\t      lengthIndex,\n\t      l,\n\t      segLength;\n\t  samples.length = lookup.length = 0;\n\n\t  for (j = startIndex + 2; j < endIndex; j += 6) {\n\t    x4 = segment[j + 4] - x1;\n\t    x3 = segment[j + 2] - x1;\n\t    x2 = segment[j] - x1;\n\t    y4 = segment[j + 5] - y1;\n\t    y3 = segment[j + 3] - y1;\n\t    y2 = segment[j + 1] - y1;\n\t    xd = xd1 = yd = yd1 = 0;\n\n\t    if (_abs(x4) < .01 && _abs(y4) < .01 && _abs(x2) + _abs(y2) < .01) {\n\t      if (segment.length > 8) {\n\t        segment.splice(j, 6);\n\t        j -= 6;\n\t        endIndex -= 6;\n\t      }\n\t    } else {\n\t      for (i = 1; i <= resolution; i++) {\n\t        t = inc * i;\n\t        inv = 1 - t;\n\t        xd = xd1 - (xd1 = (t * t * x4 + 3 * inv * (t * x3 + inv * x2)) * t);\n\t        yd = yd1 - (yd1 = (t * t * y4 + 3 * inv * (t * y3 + inv * y2)) * t);\n\t        l = _sqrt(yd * yd + xd * xd);\n\n\t        if (l < min) {\n\t          min = l;\n\t        }\n\n\t        length += l;\n\t        samples[samplesIndex++] = length;\n\t      }\n\t    }\n\n\t    x1 += x4;\n\t    y1 += y4;\n\t  }\n\n\t  if (prevLength) {\n\t    prevLength -= length;\n\n\t    for (; samplesIndex < samples.length; samplesIndex++) {\n\t      samples[samplesIndex] += prevLength;\n\t    }\n\t  }\n\n\t  if (samples.length && min) {\n\t    segment.totalLength = segLength = samples[samples.length - 1] || 0;\n\t    segment.minLength = min;\n\n\t    if (segLength / min < 9999) {\n\t      l = lengthIndex = 0;\n\n\t      for (i = 0; i < segLength; i += min) {\n\t        lookup[l++] = samples[lengthIndex] < i ? ++lengthIndex : lengthIndex;\n\t      }\n\t    }\n\t  } else {\n\t    segment.totalLength = samples[0] = 0;\n\t  }\n\n\t  return startIndex ? length - samples[startIndex / 2 - 1] : length;\n\t}\n\n\tfunction cacheRawPathMeasurements(rawPath, resolution) {\n\t  var pathLength, points, i;\n\n\t  for (i = pathLength = points = 0; i < rawPath.length; i++) {\n\t    rawPath[i].resolution = ~~resolution || 12;\n\t    points += rawPath[i].length;\n\t    pathLength += measureSegment(rawPath[i]);\n\t  }\n\n\t  rawPath.totalPoints = points;\n\t  rawPath.totalLength = pathLength;\n\t  return rawPath;\n\t}\n\tfunction subdivideSegment(segment, i, t) {\n\t  if (t <= 0 || t >= 1) {\n\t    return 0;\n\t  }\n\n\t  var ax = segment[i],\n\t      ay = segment[i + 1],\n\t      cp1x = segment[i + 2],\n\t      cp1y = segment[i + 3],\n\t      cp2x = segment[i + 4],\n\t      cp2y = segment[i + 5],\n\t      bx = segment[i + 6],\n\t      by = segment[i + 7],\n\t      x1a = ax + (cp1x - ax) * t,\n\t      x2 = cp1x + (cp2x - cp1x) * t,\n\t      y1a = ay + (cp1y - ay) * t,\n\t      y2 = cp1y + (cp2y - cp1y) * t,\n\t      x1 = x1a + (x2 - x1a) * t,\n\t      y1 = y1a + (y2 - y1a) * t,\n\t      x2a = cp2x + (bx - cp2x) * t,\n\t      y2a = cp2y + (by - cp2y) * t;\n\t  x2 += (x2a - x2) * t;\n\t  y2 += (y2a - y2) * t;\n\t  segment.splice(i + 2, 4, _round(x1a), _round(y1a), _round(x1), _round(y1), _round(x1 + (x2 - x1) * t), _round(y1 + (y2 - y1) * t), _round(x2), _round(y2), _round(x2a), _round(y2a));\n\t  segment.samples && segment.samples.splice(i / 6 * segment.resolution | 0, 0, 0, 0, 0, 0, 0, 0);\n\t  return 6;\n\t}\n\n\tfunction getProgressData(rawPath, progress, decoratee, pushToNextIfAtEnd) {\n\t  decoratee = decoratee || {};\n\t  rawPath.totalLength || cacheRawPathMeasurements(rawPath);\n\n\t  if (progress < 0 || progress > 1) {\n\t    progress = _wrapProgress(progress);\n\t  }\n\n\t  var segIndex = 0,\n\t      segment = rawPath[0],\n\t      samples,\n\t      resolution,\n\t      length,\n\t      min,\n\t      max,\n\t      i,\n\t      t;\n\n\t  if (!progress) {\n\t    t = i = segIndex = 0;\n\t    segment = rawPath[0];\n\t  } else if (progress === 1) {\n\t    t = 1;\n\t    segIndex = rawPath.length - 1;\n\t    segment = rawPath[segIndex];\n\t    i = segment.length - 8;\n\t  } else {\n\t    if (rawPath.length > 1) {\n\t      length = rawPath.totalLength * progress;\n\t      max = i = 0;\n\n\t      while ((max += rawPath[i++].totalLength) < length) {\n\t        segIndex = i;\n\t      }\n\n\t      segment = rawPath[segIndex];\n\t      min = max - segment.totalLength;\n\t      progress = (length - min) / (max - min) || 0;\n\t    }\n\n\t    samples = segment.samples;\n\t    resolution = segment.resolution;\n\t    length = segment.totalLength * progress;\n\t    i = segment.lookup.length ? segment.lookup[~~(length / segment.minLength)] || 0 : _getSampleIndex(samples, length, progress);\n\t    min = i ? samples[i - 1] : 0;\n\t    max = samples[i];\n\n\t    if (max < length) {\n\t      min = max;\n\t      max = samples[++i];\n\t    }\n\n\t    t = 1 / resolution * ((length - min) / (max - min) + i % resolution);\n\t    i = ~~(i / resolution) * 6;\n\n\t    if (pushToNextIfAtEnd && t === 1) {\n\t      if (i + 6 < segment.length) {\n\t        i += 6;\n\t        t = 0;\n\t      } else if (segIndex + 1 < rawPath.length) {\n\t        i = t = 0;\n\t        segment = rawPath[++segIndex];\n\t      }\n\t    }\n\t  }\n\n\t  decoratee.t = t;\n\t  decoratee.i = i;\n\t  decoratee.path = rawPath;\n\t  decoratee.segment = segment;\n\t  decoratee.segIndex = segIndex;\n\t  return decoratee;\n\t}\n\n\tfunction getPositionOnPath(rawPath, progress, includeAngle, point) {\n\t  var segment = rawPath[0],\n\t      result = point || {},\n\t      samples,\n\t      resolution,\n\t      length,\n\t      min,\n\t      max,\n\t      i,\n\t      t,\n\t      a,\n\t      inv;\n\n\t  if (progress < 0 || progress > 1) {\n\t    progress = _wrapProgress(progress);\n\t  }\n\n\t  segment.lookup || cacheRawPathMeasurements(rawPath);\n\n\t  if (rawPath.length > 1) {\n\t    length = rawPath.totalLength * progress;\n\t    max = i = 0;\n\n\t    while ((max += rawPath[i++].totalLength) < length) {\n\t      segment = rawPath[i];\n\t    }\n\n\t    min = max - segment.totalLength;\n\t    progress = (length - min) / (max - min) || 0;\n\t  }\n\n\t  samples = segment.samples;\n\t  resolution = segment.resolution;\n\t  length = segment.totalLength * progress;\n\t  i = segment.lookup.length ? segment.lookup[progress < 1 ? ~~(length / segment.minLength) : segment.lookup.length - 1] || 0 : _getSampleIndex(samples, length, progress);\n\t  min = i ? samples[i - 1] : 0;\n\t  max = samples[i];\n\n\t  if (max < length) {\n\t    min = max;\n\t    max = samples[++i];\n\t  }\n\n\t  t = 1 / resolution * ((length - min) / (max - min) + i % resolution) || 0;\n\t  inv = 1 - t;\n\t  i = ~~(i / resolution) * 6;\n\t  a = segment[i];\n\t  result.x = _round((t * t * (segment[i + 6] - a) + 3 * inv * (t * (segment[i + 4] - a) + inv * (segment[i + 2] - a))) * t + a);\n\t  result.y = _round((t * t * (segment[i + 7] - (a = segment[i + 1])) + 3 * inv * (t * (segment[i + 5] - a) + inv * (segment[i + 3] - a))) * t + a);\n\n\t  if (includeAngle) {\n\t    result.angle = segment.totalLength ? getRotationAtBezierT(segment, i, t >= 1 ? 1 - 1e-9 : t ? t : 1e-9) : segment.angle || 0;\n\t  }\n\n\t  return result;\n\t}\n\tfunction transformRawPath(rawPath, a, b, c, d, tx, ty) {\n\t  var j = rawPath.length,\n\t      segment,\n\t      l,\n\t      i,\n\t      x,\n\t      y;\n\n\t  while (--j > -1) {\n\t    segment = rawPath[j];\n\t    l = segment.length;\n\n\t    for (i = 0; i < l; i += 2) {\n\t      x = segment[i];\n\t      y = segment[i + 1];\n\t      segment[i] = x * a + y * c + tx;\n\t      segment[i + 1] = x * b + y * d + ty;\n\t    }\n\t  }\n\n\t  rawPath._dirty = 1;\n\t  return rawPath;\n\t}\n\n\tfunction arcToSegment(lastX, lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y) {\n\t  if (lastX === x && lastY === y) {\n\t    return;\n\t  }\n\n\t  rx = _abs(rx);\n\t  ry = _abs(ry);\n\n\t  var angleRad = angle % 360 * _DEG2RAD,\n\t      cosAngle = _cos(angleRad),\n\t      sinAngle = _sin(angleRad),\n\t      PI = Math.PI,\n\t      TWOPI = PI * 2,\n\t      dx2 = (lastX - x) / 2,\n\t      dy2 = (lastY - y) / 2,\n\t      x1 = cosAngle * dx2 + sinAngle * dy2,\n\t      y1 = -sinAngle * dx2 + cosAngle * dy2,\n\t      x1_sq = x1 * x1,\n\t      y1_sq = y1 * y1,\n\t      radiiCheck = x1_sq / (rx * rx) + y1_sq / (ry * ry);\n\n\t  if (radiiCheck > 1) {\n\t    rx = _sqrt(radiiCheck) * rx;\n\t    ry = _sqrt(radiiCheck) * ry;\n\t  }\n\n\t  var rx_sq = rx * rx,\n\t      ry_sq = ry * ry,\n\t      sq = (rx_sq * ry_sq - rx_sq * y1_sq - ry_sq * x1_sq) / (rx_sq * y1_sq + ry_sq * x1_sq);\n\n\t  if (sq < 0) {\n\t    sq = 0;\n\t  }\n\n\t  var coef = (largeArcFlag === sweepFlag ? -1 : 1) * _sqrt(sq),\n\t      cx1 = coef * (rx * y1 / ry),\n\t      cy1 = coef * -(ry * x1 / rx),\n\t      sx2 = (lastX + x) / 2,\n\t      sy2 = (lastY + y) / 2,\n\t      cx = sx2 + (cosAngle * cx1 - sinAngle * cy1),\n\t      cy = sy2 + (sinAngle * cx1 + cosAngle * cy1),\n\t      ux = (x1 - cx1) / rx,\n\t      uy = (y1 - cy1) / ry,\n\t      vx = (-x1 - cx1) / rx,\n\t      vy = (-y1 - cy1) / ry,\n\t      temp = ux * ux + uy * uy,\n\t      angleStart = (uy < 0 ? -1 : 1) * Math.acos(ux / _sqrt(temp)),\n\t      angleExtent = (ux * vy - uy * vx < 0 ? -1 : 1) * Math.acos((ux * vx + uy * vy) / _sqrt(temp * (vx * vx + vy * vy)));\n\n\t  isNaN(angleExtent) && (angleExtent = PI);\n\n\t  if (!sweepFlag && angleExtent > 0) {\n\t    angleExtent -= TWOPI;\n\t  } else if (sweepFlag && angleExtent < 0) {\n\t    angleExtent += TWOPI;\n\t  }\n\n\t  angleStart %= TWOPI;\n\t  angleExtent %= TWOPI;\n\n\t  var segments = Math.ceil(_abs(angleExtent) / (TWOPI / 4)),\n\t      rawPath = [],\n\t      angleIncrement = angleExtent / segments,\n\t      controlLength = 4 / 3 * _sin(angleIncrement / 2) / (1 + _cos(angleIncrement / 2)),\n\t      ma = cosAngle * rx,\n\t      mb = sinAngle * rx,\n\t      mc = sinAngle * -ry,\n\t      md = cosAngle * ry,\n\t      i;\n\n\t  for (i = 0; i < segments; i++) {\n\t    angle = angleStart + i * angleIncrement;\n\t    x1 = _cos(angle);\n\t    y1 = _sin(angle);\n\t    ux = _cos(angle += angleIncrement);\n\t    uy = _sin(angle);\n\t    rawPath.push(x1 - controlLength * y1, y1 + controlLength * x1, ux + controlLength * uy, uy - controlLength * ux, ux, uy);\n\t  }\n\n\t  for (i = 0; i < rawPath.length; i += 2) {\n\t    x1 = rawPath[i];\n\t    y1 = rawPath[i + 1];\n\t    rawPath[i] = x1 * ma + y1 * mc + cx;\n\t    rawPath[i + 1] = x1 * mb + y1 * md + cy;\n\t  }\n\n\t  rawPath[i - 2] = x;\n\t  rawPath[i - 1] = y;\n\t  return rawPath;\n\t}\n\n\tfunction stringToRawPath(d) {\n\t  var a = (d + \"\").replace(_scientific, function (m) {\n\t    var n = +m;\n\t    return n < 0.0001 && n > -0.0001 ? 0 : n;\n\t  }).match(_svgPathExp) || [],\n\t      path = [],\n\t      relativeX = 0,\n\t      relativeY = 0,\n\t      twoThirds = 2 / 3,\n\t      elements = a.length,\n\t      points = 0,\n\t      errorMessage = \"ERROR: malformed path: \" + d,\n\t      i,\n\t      j,\n\t      x,\n\t      y,\n\t      command,\n\t      isRelative,\n\t      segment,\n\t      startX,\n\t      startY,\n\t      difX,\n\t      difY,\n\t      beziers,\n\t      prevCommand,\n\t      flag1,\n\t      flag2,\n\t      line = function line(sx, sy, ex, ey) {\n\t    difX = (ex - sx) / 3;\n\t    difY = (ey - sy) / 3;\n\t    segment.push(sx + difX, sy + difY, ex - difX, ey - difY, ex, ey);\n\t  };\n\n\t  if (!d || !isNaN(a[0]) || isNaN(a[1])) {\n\t    console.log(errorMessage);\n\t    return path;\n\t  }\n\n\t  for (i = 0; i < elements; i++) {\n\t    prevCommand = command;\n\n\t    if (isNaN(a[i])) {\n\t      command = a[i].toUpperCase();\n\t      isRelative = command !== a[i];\n\t    } else {\n\t      i--;\n\t    }\n\n\t    x = +a[i + 1];\n\t    y = +a[i + 2];\n\n\t    if (isRelative) {\n\t      x += relativeX;\n\t      y += relativeY;\n\t    }\n\n\t    if (!i) {\n\t      startX = x;\n\t      startY = y;\n\t    }\n\n\t    if (command === \"M\") {\n\t      if (segment) {\n\t        if (segment.length < 8) {\n\t          path.length -= 1;\n\t        } else {\n\t          points += segment.length;\n\t        }\n\t      }\n\n\t      relativeX = startX = x;\n\t      relativeY = startY = y;\n\t      segment = [x, y];\n\t      path.push(segment);\n\t      i += 2;\n\t      command = \"L\";\n\t    } else if (command === \"C\") {\n\t      if (!segment) {\n\t        segment = [0, 0];\n\t      }\n\n\t      if (!isRelative) {\n\t        relativeX = relativeY = 0;\n\t      }\n\n\t      segment.push(x, y, relativeX + a[i + 3] * 1, relativeY + a[i + 4] * 1, relativeX += a[i + 5] * 1, relativeY += a[i + 6] * 1);\n\t      i += 6;\n\t    } else if (command === \"S\") {\n\t      difX = relativeX;\n\t      difY = relativeY;\n\n\t      if (prevCommand === \"C\" || prevCommand === \"S\") {\n\t        difX += relativeX - segment[segment.length - 4];\n\t        difY += relativeY - segment[segment.length - 3];\n\t      }\n\n\t      if (!isRelative) {\n\t        relativeX = relativeY = 0;\n\t      }\n\n\t      segment.push(difX, difY, x, y, relativeX += a[i + 3] * 1, relativeY += a[i + 4] * 1);\n\t      i += 4;\n\t    } else if (command === \"Q\") {\n\t      difX = relativeX + (x - relativeX) * twoThirds;\n\t      difY = relativeY + (y - relativeY) * twoThirds;\n\n\t      if (!isRelative) {\n\t        relativeX = relativeY = 0;\n\t      }\n\n\t      relativeX += a[i + 3] * 1;\n\t      relativeY += a[i + 4] * 1;\n\t      segment.push(difX, difY, relativeX + (x - relativeX) * twoThirds, relativeY + (y - relativeY) * twoThirds, relativeX, relativeY);\n\t      i += 4;\n\t    } else if (command === \"T\") {\n\t      difX = relativeX - segment[segment.length - 4];\n\t      difY = relativeY - segment[segment.length - 3];\n\t      segment.push(relativeX + difX, relativeY + difY, x + (relativeX + difX * 1.5 - x) * twoThirds, y + (relativeY + difY * 1.5 - y) * twoThirds, relativeX = x, relativeY = y);\n\t      i += 2;\n\t    } else if (command === \"H\") {\n\t      line(relativeX, relativeY, relativeX = x, relativeY);\n\t      i += 1;\n\t    } else if (command === \"V\") {\n\t      line(relativeX, relativeY, relativeX, relativeY = x + (isRelative ? relativeY - relativeX : 0));\n\t      i += 1;\n\t    } else if (command === \"L\" || command === \"Z\") {\n\t      if (command === \"Z\") {\n\t        x = startX;\n\t        y = startY;\n\t        segment.closed = true;\n\t      }\n\n\t      if (command === \"L\" || _abs(relativeX - x) > 0.5 || _abs(relativeY - y) > 0.5) {\n\t        line(relativeX, relativeY, x, y);\n\n\t        if (command === \"L\") {\n\t          i += 2;\n\t        }\n\t      }\n\n\t      relativeX = x;\n\t      relativeY = y;\n\t    } else if (command === \"A\") {\n\t      flag1 = a[i + 4];\n\t      flag2 = a[i + 5];\n\t      difX = a[i + 6];\n\t      difY = a[i + 7];\n\t      j = 7;\n\n\t      if (flag1.length > 1) {\n\t        if (flag1.length < 3) {\n\t          difY = difX;\n\t          difX = flag2;\n\t          j--;\n\t        } else {\n\t          difY = flag2;\n\t          difX = flag1.substr(2);\n\t          j -= 2;\n\t        }\n\n\t        flag2 = flag1.charAt(1);\n\t        flag1 = flag1.charAt(0);\n\t      }\n\n\t      beziers = arcToSegment(relativeX, relativeY, +a[i + 1], +a[i + 2], +a[i + 3], +flag1, +flag2, (isRelative ? relativeX : 0) + difX * 1, (isRelative ? relativeY : 0) + difY * 1);\n\t      i += j;\n\n\t      if (beziers) {\n\t        for (j = 0; j < beziers.length; j++) {\n\t          segment.push(beziers[j]);\n\t        }\n\t      }\n\n\t      relativeX = segment[segment.length - 2];\n\t      relativeY = segment[segment.length - 1];\n\t    } else {\n\t      console.log(errorMessage);\n\t    }\n\t  }\n\n\t  i = segment.length;\n\n\t  if (i < 6) {\n\t    path.pop();\n\t    i = 0;\n\t  } else if (segment[0] === segment[i - 2] && segment[1] === segment[i - 1]) {\n\t    segment.closed = true;\n\t  }\n\n\t  path.totalPoints = points + i;\n\t  return path;\n\t}\n\tfunction flatPointsToSegment(points, curviness) {\n\t  if (curviness === void 0) {\n\t    curviness = 1;\n\t  }\n\n\t  var x = points[0],\n\t      y = 0,\n\t      segment = [x, y],\n\t      i = 2;\n\n\t  for (; i < points.length; i += 2) {\n\t    segment.push(x, y, points[i], y = (points[i] - x) * curviness / 2, x = points[i], -y);\n\t  }\n\n\t  return segment;\n\t}\n\tfunction pointsToSegment(points, curviness) {\n\t  _abs(points[0] - points[2]) < 1e-4 && _abs(points[1] - points[3]) < 1e-4 && (points = points.slice(2));\n\t  var l = points.length - 2,\n\t      x = +points[0],\n\t      y = +points[1],\n\t      nextX = +points[2],\n\t      nextY = +points[3],\n\t      segment = [x, y, x, y],\n\t      dx2 = nextX - x,\n\t      dy2 = nextY - y,\n\t      closed = Math.abs(points[l] - x) < 0.001 && Math.abs(points[l + 1] - y) < 0.001,\n\t      prevX,\n\t      prevY,\n\t      i,\n\t      dx1,\n\t      dy1,\n\t      r1,\n\t      r2,\n\t      r3,\n\t      tl,\n\t      mx1,\n\t      mx2,\n\t      mxm,\n\t      my1,\n\t      my2,\n\t      mym;\n\n\t  if (closed) {\n\t    points.push(nextX, nextY);\n\t    nextX = x;\n\t    nextY = y;\n\t    x = points[l - 2];\n\t    y = points[l - 1];\n\t    points.unshift(x, y);\n\t    l += 4;\n\t  }\n\n\t  curviness = curviness || curviness === 0 ? +curviness : 1;\n\n\t  for (i = 2; i < l; i += 2) {\n\t    prevX = x;\n\t    prevY = y;\n\t    x = nextX;\n\t    y = nextY;\n\t    nextX = +points[i + 2];\n\t    nextY = +points[i + 3];\n\n\t    if (x === nextX && y === nextY) {\n\t      continue;\n\t    }\n\n\t    dx1 = dx2;\n\t    dy1 = dy2;\n\t    dx2 = nextX - x;\n\t    dy2 = nextY - y;\n\t    r1 = _sqrt(dx1 * dx1 + dy1 * dy1);\n\t    r2 = _sqrt(dx2 * dx2 + dy2 * dy2);\n\t    r3 = _sqrt(Math.pow(dx2 / r2 + dx1 / r1, 2) + Math.pow(dy2 / r2 + dy1 / r1, 2));\n\t    tl = (r1 + r2) * curviness * 0.25 / r3;\n\t    mx1 = x - (x - prevX) * (r1 ? tl / r1 : 0);\n\t    mx2 = x + (nextX - x) * (r2 ? tl / r2 : 0);\n\t    mxm = x - (mx1 + ((mx2 - mx1) * (r1 * 3 / (r1 + r2) + 0.5) / 4 || 0));\n\t    my1 = y - (y - prevY) * (r1 ? tl / r1 : 0);\n\t    my2 = y + (nextY - y) * (r2 ? tl / r2 : 0);\n\t    mym = y - (my1 + ((my2 - my1) * (r1 * 3 / (r1 + r2) + 0.5) / 4 || 0));\n\n\t    if (x !== prevX || y !== prevY) {\n\t      segment.push(_round(mx1 + mxm), _round(my1 + mym), _round(x), _round(y), _round(mx2 + mxm), _round(my2 + mym));\n\t    }\n\t  }\n\n\t  x !== nextX || y !== nextY || segment.length < 4 ? segment.push(_round(nextX), _round(nextY), _round(nextX), _round(nextY)) : segment.length -= 2;\n\n\t  if (segment.length === 2) {\n\t    segment.push(x, y, x, y, x, y);\n\t  } else if (closed) {\n\t    segment.splice(0, 6);\n\t    segment.length = segment.length - 6;\n\t  }\n\n\t  return segment;\n\t}\n\tfunction rawPathToString(rawPath) {\n\t  if (_isNumber(rawPath[0])) {\n\t    rawPath = [rawPath];\n\t  }\n\n\t  var result = \"\",\n\t      l = rawPath.length,\n\t      sl,\n\t      s,\n\t      i,\n\t      segment;\n\n\t  for (s = 0; s < l; s++) {\n\t    segment = rawPath[s];\n\t    result += \"M\" + _round(segment[0]) + \",\" + _round(segment[1]) + \" C\";\n\t    sl = segment.length;\n\n\t    for (i = 2; i < sl; i++) {\n\t      result += _round(segment[i++]) + \",\" + _round(segment[i++]) + \" \" + _round(segment[i++]) + \",\" + _round(segment[i++]) + \" \" + _round(segment[i++]) + \",\" + _round(segment[i]) + \" \";\n\t    }\n\n\t    if (segment.closed) {\n\t      result += \"z\";\n\t    }\n\t  }\n\n\t  return result;\n\t}\n\n\tvar _doc,\n\t    _win,\n\t    _docElement,\n\t    _body,\n\t    _divContainer,\n\t    _svgContainer,\n\t    _identityMatrix,\n\t    _gEl,\n\t    _transformProp = \"transform\",\n\t    _transformOriginProp = _transformProp + \"Origin\",\n\t    _hasOffsetBug,\n\t    _setDoc = function _setDoc(element) {\n\t  var doc = element.ownerDocument || element;\n\n\t  if (!(_transformProp in element.style) && \"msTransform\" in element.style) {\n\t    _transformProp = \"msTransform\";\n\t    _transformOriginProp = _transformProp + \"Origin\";\n\t  }\n\n\t  while (doc.parentNode && (doc = doc.parentNode)) {}\n\n\t  _win = window;\n\t  _identityMatrix = new Matrix2D();\n\n\t  if (doc) {\n\t    _doc = doc;\n\t    _docElement = doc.documentElement;\n\t    _body = doc.body;\n\t    _gEl = _doc.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n\t    _gEl.style.transform = \"none\";\n\t    var d1 = doc.createElement(\"div\"),\n\t        d2 = doc.createElement(\"div\"),\n\t        root = doc && (doc.body || doc.firstElementChild);\n\n\t    if (root && root.appendChild) {\n\t      root.appendChild(d1);\n\t      d1.appendChild(d2);\n\t      d1.setAttribute(\"style\", \"position:static;transform:translate3d(0,0,1px)\");\n\t      _hasOffsetBug = d2.offsetParent !== d1;\n\t      root.removeChild(d1);\n\t    }\n\t  }\n\n\t  return doc;\n\t},\n\t    _forceNonZeroScale = function _forceNonZeroScale(e) {\n\t  var a, cache;\n\n\t  while (e && e !== _body) {\n\t    cache = e._gsap;\n\t    cache && cache.uncache && cache.get(e, \"x\");\n\n\t    if (cache && !cache.scaleX && !cache.scaleY && cache.renderTransform) {\n\t      cache.scaleX = cache.scaleY = 1e-4;\n\t      cache.renderTransform(1, cache);\n\t      a ? a.push(cache) : a = [cache];\n\t    }\n\n\t    e = e.parentNode;\n\t  }\n\n\t  return a;\n\t},\n\t    _svgTemps = [],\n\t    _divTemps = [],\n\t    _getDocScrollTop = function _getDocScrollTop() {\n\t  return _win.pageYOffset || _doc.scrollTop || _docElement.scrollTop || _body.scrollTop || 0;\n\t},\n\t    _getDocScrollLeft = function _getDocScrollLeft() {\n\t  return _win.pageXOffset || _doc.scrollLeft || _docElement.scrollLeft || _body.scrollLeft || 0;\n\t},\n\t    _svgOwner = function _svgOwner(element) {\n\t  return element.ownerSVGElement || ((element.tagName + \"\").toLowerCase() === \"svg\" ? element : null);\n\t},\n\t    _isFixed = function _isFixed(element) {\n\t  if (_win.getComputedStyle(element).position === \"fixed\") {\n\t    return true;\n\t  }\n\n\t  element = element.parentNode;\n\n\t  if (element && element.nodeType === 1) {\n\t    return _isFixed(element);\n\t  }\n\t},\n\t    _createSibling = function _createSibling(element, i) {\n\t  if (element.parentNode && (_doc || _setDoc(element))) {\n\t    var svg = _svgOwner(element),\n\t        ns = svg ? svg.getAttribute(\"xmlns\") || \"http://www.w3.org/2000/svg\" : \"http://www.w3.org/1999/xhtml\",\n\t        type = svg ? i ? \"rect\" : \"g\" : \"div\",\n\t        x = i !== 2 ? 0 : 100,\n\t        y = i === 3 ? 100 : 0,\n\t        css = \"position:absolute;display:block;pointer-events:none;margin:0;padding:0;\",\n\t        e = _doc.createElementNS ? _doc.createElementNS(ns.replace(/^https/, \"http\"), type) : _doc.createElement(type);\n\n\t    if (i) {\n\t      if (!svg) {\n\t        if (!_divContainer) {\n\t          _divContainer = _createSibling(element);\n\t          _divContainer.style.cssText = css;\n\t        }\n\n\t        e.style.cssText = css + \"width:0.1px;height:0.1px;top:\" + y + \"px;left:\" + x + \"px\";\n\n\t        _divContainer.appendChild(e);\n\t      } else {\n\t        _svgContainer || (_svgContainer = _createSibling(element));\n\t        e.setAttribute(\"width\", 0.01);\n\t        e.setAttribute(\"height\", 0.01);\n\t        e.setAttribute(\"transform\", \"translate(\" + x + \",\" + y + \")\");\n\n\t        _svgContainer.appendChild(e);\n\t      }\n\t    }\n\n\t    return e;\n\t  }\n\n\t  throw \"Need document and parent.\";\n\t},\n\t    _consolidate = function _consolidate(m) {\n\t  var c = new Matrix2D(),\n\t      i = 0;\n\n\t  for (; i < m.numberOfItems; i++) {\n\t    c.multiply(m.getItem(i).matrix);\n\t  }\n\n\t  return c;\n\t},\n\t    _getCTM = function _getCTM(svg) {\n\t  var m = svg.getCTM(),\n\t      transform;\n\n\t  if (!m) {\n\t    transform = svg.style[_transformProp];\n\t    svg.style[_transformProp] = \"none\";\n\t    svg.appendChild(_gEl);\n\t    m = _gEl.getCTM();\n\t    svg.removeChild(_gEl);\n\t    transform ? svg.style[_transformProp] = transform : svg.style.removeProperty(_transformProp.replace(/([A-Z])/g, \"-$1\").toLowerCase());\n\t  }\n\n\t  return m || _identityMatrix.clone();\n\t},\n\t    _placeSiblings = function _placeSiblings(element, adjustGOffset) {\n\t  var svg = _svgOwner(element),\n\t      isRootSVG = element === svg,\n\t      siblings = svg ? _svgTemps : _divTemps,\n\t      parent = element.parentNode,\n\t      container,\n\t      m,\n\t      b,\n\t      x,\n\t      y,\n\t      cs;\n\n\t  if (element === _win) {\n\t    return element;\n\t  }\n\n\t  siblings.length || siblings.push(_createSibling(element, 1), _createSibling(element, 2), _createSibling(element, 3));\n\t  container = svg ? _svgContainer : _divContainer;\n\n\t  if (svg) {\n\t    if (isRootSVG) {\n\t      b = _getCTM(element);\n\t      x = -b.e / b.a;\n\t      y = -b.f / b.d;\n\t      m = _identityMatrix;\n\t    } else if (element.getBBox) {\n\t      b = element.getBBox();\n\t      m = element.transform ? element.transform.baseVal : {};\n\t      m = !m.numberOfItems ? _identityMatrix : m.numberOfItems > 1 ? _consolidate(m) : m.getItem(0).matrix;\n\t      x = m.a * b.x + m.c * b.y;\n\t      y = m.b * b.x + m.d * b.y;\n\t    } else {\n\t      m = new Matrix2D();\n\t      x = y = 0;\n\t    }\n\n\t    if (adjustGOffset && element.tagName.toLowerCase() === \"g\") {\n\t      x = y = 0;\n\t    }\n\n\t    (isRootSVG ? svg : parent).appendChild(container);\n\t    container.setAttribute(\"transform\", \"matrix(\" + m.a + \",\" + m.b + \",\" + m.c + \",\" + m.d + \",\" + (m.e + x) + \",\" + (m.f + y) + \")\");\n\t  } else {\n\t    x = y = 0;\n\n\t    if (_hasOffsetBug) {\n\t      m = element.offsetParent;\n\t      b = element;\n\n\t      while (b && (b = b.parentNode) && b !== m && b.parentNode) {\n\t        if ((_win.getComputedStyle(b)[_transformProp] + \"\").length > 4) {\n\t          x = b.offsetLeft;\n\t          y = b.offsetTop;\n\t          b = 0;\n\t        }\n\t      }\n\t    }\n\n\t    cs = _win.getComputedStyle(element);\n\n\t    if (cs.position !== \"absolute\" && cs.position !== \"fixed\") {\n\t      m = element.offsetParent;\n\n\t      while (parent && parent !== m) {\n\t        x += parent.scrollLeft || 0;\n\t        y += parent.scrollTop || 0;\n\t        parent = parent.parentNode;\n\t      }\n\t    }\n\n\t    b = container.style;\n\t    b.top = element.offsetTop - y + \"px\";\n\t    b.left = element.offsetLeft - x + \"px\";\n\t    b[_transformProp] = cs[_transformProp];\n\t    b[_transformOriginProp] = cs[_transformOriginProp];\n\t    b.position = cs.position === \"fixed\" ? \"fixed\" : \"absolute\";\n\t    element.parentNode.appendChild(container);\n\t  }\n\n\t  return container;\n\t},\n\t    _setMatrix = function _setMatrix(m, a, b, c, d, e, f) {\n\t  m.a = a;\n\t  m.b = b;\n\t  m.c = c;\n\t  m.d = d;\n\t  m.e = e;\n\t  m.f = f;\n\t  return m;\n\t};\n\n\tvar Matrix2D = function () {\n\t  function Matrix2D(a, b, c, d, e, f) {\n\t    if (a === void 0) {\n\t      a = 1;\n\t    }\n\n\t    if (b === void 0) {\n\t      b = 0;\n\t    }\n\n\t    if (c === void 0) {\n\t      c = 0;\n\t    }\n\n\t    if (d === void 0) {\n\t      d = 1;\n\t    }\n\n\t    if (e === void 0) {\n\t      e = 0;\n\t    }\n\n\t    if (f === void 0) {\n\t      f = 0;\n\t    }\n\n\t    _setMatrix(this, a, b, c, d, e, f);\n\t  }\n\n\t  var _proto = Matrix2D.prototype;\n\n\t  _proto.inverse = function inverse() {\n\t    var a = this.a,\n\t        b = this.b,\n\t        c = this.c,\n\t        d = this.d,\n\t        e = this.e,\n\t        f = this.f,\n\t        determinant = a * d - b * c || 1e-10;\n\t    return _setMatrix(this, d / determinant, -b / determinant, -c / determinant, a / determinant, (c * f - d * e) / determinant, -(a * f - b * e) / determinant);\n\t  };\n\n\t  _proto.multiply = function multiply(matrix) {\n\t    var a = this.a,\n\t        b = this.b,\n\t        c = this.c,\n\t        d = this.d,\n\t        e = this.e,\n\t        f = this.f,\n\t        a2 = matrix.a,\n\t        b2 = matrix.c,\n\t        c2 = matrix.b,\n\t        d2 = matrix.d,\n\t        e2 = matrix.e,\n\t        f2 = matrix.f;\n\t    return _setMatrix(this, a2 * a + c2 * c, a2 * b + c2 * d, b2 * a + d2 * c, b2 * b + d2 * d, e + e2 * a + f2 * c, f + e2 * b + f2 * d);\n\t  };\n\n\t  _proto.clone = function clone() {\n\t    return new Matrix2D(this.a, this.b, this.c, this.d, this.e, this.f);\n\t  };\n\n\t  _proto.equals = function equals(matrix) {\n\t    var a = this.a,\n\t        b = this.b,\n\t        c = this.c,\n\t        d = this.d,\n\t        e = this.e,\n\t        f = this.f;\n\t    return a === matrix.a && b === matrix.b && c === matrix.c && d === matrix.d && e === matrix.e && f === matrix.f;\n\t  };\n\n\t  _proto.apply = function apply(point, decoratee) {\n\t    if (decoratee === void 0) {\n\t      decoratee = {};\n\t    }\n\n\t    var x = point.x,\n\t        y = point.y,\n\t        a = this.a,\n\t        b = this.b,\n\t        c = this.c,\n\t        d = this.d,\n\t        e = this.e,\n\t        f = this.f;\n\t    decoratee.x = x * a + y * c + e || 0;\n\t    decoratee.y = x * b + y * d + f || 0;\n\t    return decoratee;\n\t  };\n\n\t  return Matrix2D;\n\t}();\n\tfunction getGlobalMatrix(element, inverse, adjustGOffset, includeScrollInFixed) {\n\t  if (!element || !element.parentNode || (_doc || _setDoc(element)).documentElement === element) {\n\t    return new Matrix2D();\n\t  }\n\n\t  var zeroScales = _forceNonZeroScale(element),\n\t      svg = _svgOwner(element),\n\t      temps = svg ? _svgTemps : _divTemps,\n\t      container = _placeSiblings(element, adjustGOffset),\n\t      b1 = temps[0].getBoundingClientRect(),\n\t      b2 = temps[1].getBoundingClientRect(),\n\t      b3 = temps[2].getBoundingClientRect(),\n\t      parent = container.parentNode,\n\t      isFixed = !includeScrollInFixed && _isFixed(element),\n\t      m = new Matrix2D((b2.left - b1.left) / 100, (b2.top - b1.top) / 100, (b3.left - b1.left) / 100, (b3.top - b1.top) / 100, b1.left + (isFixed ? 0 : _getDocScrollLeft()), b1.top + (isFixed ? 0 : _getDocScrollTop()));\n\n\t  parent.removeChild(container);\n\n\t  if (zeroScales) {\n\t    b1 = zeroScales.length;\n\n\t    while (b1--) {\n\t      b2 = zeroScales[b1];\n\t      b2.scaleX = b2.scaleY = 0;\n\t      b2.renderTransform(1, b2);\n\t    }\n\t  }\n\n\t  return inverse ? m.inverse() : m;\n\t}\n\n\t/*!\n\t * MotionPathPlugin 3.12.5\n\t * https://gsap.com\n\t *\n\t * @license Copyright 2008-2024, GreenSock. All rights reserved.\n\t * Subject to the terms at https://gsap.com/standard-license or for\n\t * Club GSAP members, the agreement issued with that membership.\n\t * @author: Jack Doyle, jack@greensock.com\n\t*/\n\n\tvar _xProps = \"x,translateX,left,marginLeft,xPercent\".split(\",\"),\n\t    _yProps = \"y,translateY,top,marginTop,yPercent\".split(\",\"),\n\t    _DEG2RAD$1 = Math.PI / 180,\n\t    gsap,\n\t    PropTween,\n\t    _getUnit,\n\t    _toArray,\n\t    _getStyleSaver,\n\t    _reverting,\n\t    _getGSAP = function _getGSAP() {\n\t  return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n\t},\n\t    _populateSegmentFromArray = function _populateSegmentFromArray(segment, values, property, mode) {\n\t  var l = values.length,\n\t      si = mode === 2 ? 0 : mode,\n\t      i = 0,\n\t      v;\n\n\t  for (; i < l; i++) {\n\t    segment[si] = v = parseFloat(values[i][property]);\n\t    mode === 2 && (segment[si + 1] = 0);\n\t    si += 2;\n\t  }\n\n\t  return segment;\n\t},\n\t    _getPropNum = function _getPropNum(target, prop, unit) {\n\t  return parseFloat(target._gsap.get(target, prop, unit || \"px\")) || 0;\n\t},\n\t    _relativize = function _relativize(segment) {\n\t  var x = segment[0],\n\t      y = segment[1],\n\t      i;\n\n\t  for (i = 2; i < segment.length; i += 2) {\n\t    x = segment[i] += x;\n\t    y = segment[i + 1] += y;\n\t  }\n\t},\n\t    _segmentToRawPath = function _segmentToRawPath(plugin, segment, target, x, y, slicer, vars, unitX, unitY) {\n\t  if (vars.type === \"cubic\") {\n\t    segment = [segment];\n\t  } else {\n\t    vars.fromCurrent !== false && segment.unshift(_getPropNum(target, x, unitX), y ? _getPropNum(target, y, unitY) : 0);\n\t    vars.relative && _relativize(segment);\n\t    var pointFunc = y ? pointsToSegment : flatPointsToSegment;\n\t    segment = [pointFunc(segment, vars.curviness)];\n\t  }\n\n\t  segment = slicer(_align(segment, target, vars));\n\n\t  _addDimensionalPropTween(plugin, target, x, segment, \"x\", unitX);\n\n\t  y && _addDimensionalPropTween(plugin, target, y, segment, \"y\", unitY);\n\t  return cacheRawPathMeasurements(segment, vars.resolution || (vars.curviness === 0 ? 20 : 12));\n\t},\n\t    _emptyFunc = function _emptyFunc(v) {\n\t  return v;\n\t},\n\t    _numExp = /[-+\\.]*\\d+\\.?(?:e-|e\\+)?\\d*/g,\n\t    _originToPoint = function _originToPoint(element, origin, parentMatrix) {\n\t  var m = getGlobalMatrix(element),\n\t      x = 0,\n\t      y = 0,\n\t      svg;\n\n\t  if ((element.tagName + \"\").toLowerCase() === \"svg\") {\n\t    svg = element.viewBox.baseVal;\n\t    svg.width || (svg = {\n\t      width: +element.getAttribute(\"width\"),\n\t      height: +element.getAttribute(\"height\")\n\t    });\n\t  } else {\n\t    svg = origin && element.getBBox && element.getBBox();\n\t  }\n\n\t  if (origin && origin !== \"auto\") {\n\t    x = origin.push ? origin[0] * (svg ? svg.width : element.offsetWidth || 0) : origin.x;\n\t    y = origin.push ? origin[1] * (svg ? svg.height : element.offsetHeight || 0) : origin.y;\n\t  }\n\n\t  return parentMatrix.apply(x || y ? m.apply({\n\t    x: x,\n\t    y: y\n\t  }) : {\n\t    x: m.e,\n\t    y: m.f\n\t  });\n\t},\n\t    _getAlignMatrix = function _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin) {\n\t  var parentMatrix = getGlobalMatrix(fromElement.parentNode, true, true),\n\t      m = parentMatrix.clone().multiply(getGlobalMatrix(toElement)),\n\t      fromPoint = _originToPoint(fromElement, fromOrigin, parentMatrix),\n\t      _originToPoint2 = _originToPoint(toElement, toOrigin, parentMatrix),\n\t      x = _originToPoint2.x,\n\t      y = _originToPoint2.y,\n\t      p;\n\n\t  m.e = m.f = 0;\n\n\t  if (toOrigin === \"auto\" && toElement.getTotalLength && toElement.tagName.toLowerCase() === \"path\") {\n\t    p = toElement.getAttribute(\"d\").match(_numExp) || [];\n\t    p = m.apply({\n\t      x: +p[0],\n\t      y: +p[1]\n\t    });\n\t    x += p.x;\n\t    y += p.y;\n\t  }\n\n\t  if (p) {\n\t    p = m.apply(toElement.getBBox());\n\t    x -= p.x;\n\t    y -= p.y;\n\t  }\n\n\t  m.e = x - fromPoint.x;\n\t  m.f = y - fromPoint.y;\n\t  return m;\n\t},\n\t    _align = function _align(rawPath, target, _ref) {\n\t  var align = _ref.align,\n\t      matrix = _ref.matrix,\n\t      offsetX = _ref.offsetX,\n\t      offsetY = _ref.offsetY,\n\t      alignOrigin = _ref.alignOrigin;\n\n\t  var x = rawPath[0][0],\n\t      y = rawPath[0][1],\n\t      curX = _getPropNum(target, \"x\"),\n\t      curY = _getPropNum(target, \"y\"),\n\t      alignTarget,\n\t      m,\n\t      p;\n\n\t  if (!rawPath || !rawPath.length) {\n\t    return getRawPath(\"M0,0L0,0\");\n\t  }\n\n\t  if (align) {\n\t    if (align === \"self\" || (alignTarget = _toArray(align)[0] || target) === target) {\n\t      transformRawPath(rawPath, 1, 0, 0, 1, curX - x, curY - y);\n\t    } else {\n\t      if (alignOrigin && alignOrigin[2] !== false) {\n\t        gsap.set(target, {\n\t          transformOrigin: alignOrigin[0] * 100 + \"% \" + alignOrigin[1] * 100 + \"%\"\n\t        });\n\t      } else {\n\t        alignOrigin = [_getPropNum(target, \"xPercent\") / -100, _getPropNum(target, \"yPercent\") / -100];\n\t      }\n\n\t      m = _getAlignMatrix(target, alignTarget, alignOrigin, \"auto\");\n\t      p = m.apply({\n\t        x: x,\n\t        y: y\n\t      });\n\t      transformRawPath(rawPath, m.a, m.b, m.c, m.d, curX + m.e - (p.x - m.e), curY + m.f - (p.y - m.f));\n\t    }\n\t  }\n\n\t  if (matrix) {\n\t    transformRawPath(rawPath, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);\n\t  } else if (offsetX || offsetY) {\n\t    transformRawPath(rawPath, 1, 0, 0, 1, offsetX || 0, offsetY || 0);\n\t  }\n\n\t  return rawPath;\n\t},\n\t    _addDimensionalPropTween = function _addDimensionalPropTween(plugin, target, property, rawPath, pathProperty, forceUnit) {\n\t  var cache = target._gsap,\n\t      harness = cache.harness,\n\t      alias = harness && harness.aliases && harness.aliases[property],\n\t      prop = alias && alias.indexOf(\",\") < 0 ? alias : property,\n\t      pt = plugin._pt = new PropTween(plugin._pt, target, prop, 0, 0, _emptyFunc, 0, cache.set(target, prop, plugin));\n\t  pt.u = _getUnit(cache.get(target, prop, forceUnit)) || 0;\n\t  pt.path = rawPath;\n\t  pt.pp = pathProperty;\n\n\t  plugin._props.push(prop);\n\t},\n\t    _sliceModifier = function _sliceModifier(start, end) {\n\t  return function (rawPath) {\n\t    return start || end !== 1 ? sliceRawPath(rawPath, start, end) : rawPath;\n\t  };\n\t};\n\n\tvar MotionPathPlugin = {\n\t  version: \"3.12.5\",\n\t  name: \"motionPath\",\n\t  register: function register(core, Plugin, propTween) {\n\t    gsap = core;\n\t    _getUnit = gsap.utils.getUnit;\n\t    _toArray = gsap.utils.toArray;\n\t    _getStyleSaver = gsap.core.getStyleSaver;\n\n\t    _reverting = gsap.core.reverting || function () {};\n\n\t    PropTween = propTween;\n\t  },\n\t  init: function init(target, vars, tween) {\n\t    if (!gsap) {\n\t      console.warn(\"Please gsap.registerPlugin(MotionPathPlugin)\");\n\t      return false;\n\t    }\n\n\t    if (!(typeof vars === \"object\" && !vars.style) || !vars.path) {\n\t      vars = {\n\t        path: vars\n\t      };\n\t    }\n\n\t    var rawPaths = [],\n\t        _vars = vars,\n\t        path = _vars.path,\n\t        autoRotate = _vars.autoRotate,\n\t        unitX = _vars.unitX,\n\t        unitY = _vars.unitY,\n\t        x = _vars.x,\n\t        y = _vars.y,\n\t        firstObj = path[0],\n\t        slicer = _sliceModifier(vars.start, \"end\" in vars ? vars.end : 1),\n\t        rawPath,\n\t        p;\n\n\t    this.rawPaths = rawPaths;\n\t    this.target = target;\n\t    this.tween = tween;\n\t    this.styles = _getStyleSaver && _getStyleSaver(target, \"transform\");\n\n\t    if (this.rotate = autoRotate || autoRotate === 0) {\n\t      this.rOffset = parseFloat(autoRotate) || 0;\n\t      this.radians = !!vars.useRadians;\n\t      this.rProp = vars.rotation || \"rotation\";\n\t      this.rSet = target._gsap.set(target, this.rProp, this);\n\t      this.ru = _getUnit(target._gsap.get(target, this.rProp)) || 0;\n\t    }\n\n\t    if (Array.isArray(path) && !(\"closed\" in path) && typeof firstObj !== \"number\") {\n\t      for (p in firstObj) {\n\t        if (!x && ~_xProps.indexOf(p)) {\n\t          x = p;\n\t        } else if (!y && ~_yProps.indexOf(p)) {\n\t          y = p;\n\t        }\n\t      }\n\n\t      if (x && y) {\n\t        rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray(_populateSegmentFromArray([], path, x, 0), path, y, 1), target, x, y, slicer, vars, unitX || _getUnit(path[0][x]), unitY || _getUnit(path[0][y])));\n\t      } else {\n\t        x = y = 0;\n\t      }\n\n\t      for (p in firstObj) {\n\t        p !== x && p !== y && rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray([], path, p, 2), target, p, 0, slicer, vars, _getUnit(path[0][p])));\n\t      }\n\t    } else {\n\t      rawPath = slicer(_align(getRawPath(vars.path), target, vars));\n\t      cacheRawPathMeasurements(rawPath, vars.resolution);\n\t      rawPaths.push(rawPath);\n\n\t      _addDimensionalPropTween(this, target, vars.x || \"x\", rawPath, \"x\", vars.unitX || \"px\");\n\n\t      _addDimensionalPropTween(this, target, vars.y || \"y\", rawPath, \"y\", vars.unitY || \"px\");\n\t    }\n\t  },\n\t  render: function render(ratio, data) {\n\t    var rawPaths = data.rawPaths,\n\t        i = rawPaths.length,\n\t        pt = data._pt;\n\n\t    if (data.tween._time || !_reverting()) {\n\t      if (ratio > 1) {\n\t        ratio = 1;\n\t      } else if (ratio < 0) {\n\t        ratio = 0;\n\t      }\n\n\t      while (i--) {\n\t        getPositionOnPath(rawPaths[i], ratio, !i && data.rotate, rawPaths[i]);\n\t      }\n\n\t      while (pt) {\n\t        pt.set(pt.t, pt.p, pt.path[pt.pp] + pt.u, pt.d, ratio);\n\t        pt = pt._next;\n\t      }\n\n\t      data.rotate && data.rSet(data.target, data.rProp, rawPaths[0].angle * (data.radians ? _DEG2RAD$1 : 1) + data.rOffset + data.ru, data, ratio);\n\t    } else {\n\t      data.styles.revert();\n\t    }\n\t  },\n\t  getLength: function getLength(path) {\n\t    return cacheRawPathMeasurements(getRawPath(path)).totalLength;\n\t  },\n\t  sliceRawPath: sliceRawPath,\n\t  getRawPath: getRawPath,\n\t  pointsToSegment: pointsToSegment,\n\t  stringToRawPath: stringToRawPath,\n\t  rawPathToString: rawPathToString,\n\t  transformRawPath: transformRawPath,\n\t  getGlobalMatrix: getGlobalMatrix,\n\t  getPositionOnPath: getPositionOnPath,\n\t  cacheRawPathMeasurements: cacheRawPathMeasurements,\n\t  convertToPath: function convertToPath$1(targets, swap) {\n\t    return _toArray(targets).map(function (target) {\n\t      return convertToPath(target, swap !== false);\n\t    });\n\t  },\n\t  convertCoordinates: function convertCoordinates(fromElement, toElement, point) {\n\t    var m = getGlobalMatrix(toElement, true, true).multiply(getGlobalMatrix(fromElement));\n\t    return point ? m.apply(point) : m;\n\t  },\n\t  getAlignMatrix: _getAlignMatrix,\n\t  getRelativePosition: function getRelativePosition(fromElement, toElement, fromOrigin, toOrigin) {\n\t    var m = _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin);\n\n\t    return {\n\t      x: m.e,\n\t      y: m.f\n\t    };\n\t  },\n\t  arrayToRawPath: function arrayToRawPath(value, vars) {\n\t    vars = vars || {};\n\n\t    var segment = _populateSegmentFromArray(_populateSegmentFromArray([], value, vars.x || \"x\", 0), value, vars.y || \"y\", 1);\n\n\t    vars.relative && _relativize(segment);\n\t    return [vars.type === \"cubic\" ? segment : pointsToSegment(segment, vars.curviness)];\n\t  }\n\t};\n\t_getGSAP() && gsap.registerPlugin(MotionPathPlugin);\n\n\texports.MotionPathPlugin = MotionPathPlugin;\n\texports.default = MotionPathPlugin;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3NhcC9kaXN0L01vdGlvblBhdGhQbHVnaW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxDQUFDLEtBQTREO0FBQzdELENBQUMsQ0FDdUU7QUFDeEUsQ0FBQyw2QkFBNkI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDLG9CQUFvQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLGNBQWM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGNBQWMsb0JBQW9CLFNBQVMsVUFBVTtBQUN2Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLGFBQWEsZ0JBQWdCOztBQUUzRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxxQkFBcUI7QUFDL0I7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdEQUFnRCxhQUFhOztBQUU3RCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9nc2FwL2Rpc3QvTW90aW9uUGF0aFBsdWdpbi5qcz8yODAwIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC53aW5kb3cgPSBnbG9iYWwud2luZG93IHx8IHt9KSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cblx0dmFyIF9zdmdQYXRoRXhwID0gL1thY2hsbXFzdHZ6XXwoLT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspPylbMC05XS9pZyxcblx0ICAgIF9udW1iZXJzRXhwID0gLyg/OigtKT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspPylbMC05XS9pZyxcblx0ICAgIF9zY2llbnRpZmljID0gL1tcXCtcXC1dP1xcZCpcXC4/XFxkK2VbXFwrXFwtXT9cXGQrL2lnLFxuXHQgICAgX3NlbGVjdG9yRXhwID0gLyheWyNcXC5dW2Etel18W2EteV1bYS16XSkvaSxcblx0ICAgIF9ERUcyUkFEID0gTWF0aC5QSSAvIDE4MCxcblx0ICAgIF9SQUQyREVHID0gMTgwIC8gTWF0aC5QSSxcblx0ICAgIF9zaW4gPSBNYXRoLnNpbixcblx0ICAgIF9jb3MgPSBNYXRoLmNvcyxcblx0ICAgIF9hYnMgPSBNYXRoLmFicyxcblx0ICAgIF9zcXJ0ID0gTWF0aC5zcXJ0LFxuXHQgICAgX2F0YW4yID0gTWF0aC5hdGFuMixcblx0ICAgIF9sYXJnZU51bSA9IDFlOCxcblx0ICAgIF9pc1N0cmluZyA9IGZ1bmN0aW9uIF9pc1N0cmluZyh2YWx1ZSkge1xuXHQgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG5cdH0sXG5cdCAgICBfaXNOdW1iZXIgPSBmdW5jdGlvbiBfaXNOdW1iZXIodmFsdWUpIHtcblx0ICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xuXHR9LFxuXHQgICAgX2lzVW5kZWZpbmVkID0gZnVuY3Rpb24gX2lzVW5kZWZpbmVkKHZhbHVlKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIjtcblx0fSxcblx0ICAgIF90ZW1wID0ge30sXG5cdCAgICBfdGVtcDIgPSB7fSxcblx0ICAgIF9yb3VuZGluZ051bSA9IDFlNSxcblx0ICAgIF93cmFwUHJvZ3Jlc3MgPSBmdW5jdGlvbiBfd3JhcFByb2dyZXNzKHByb2dyZXNzKSB7XG5cdCAgcmV0dXJuIE1hdGgucm91bmQoKHByb2dyZXNzICsgX2xhcmdlTnVtKSAlIDEgKiBfcm91bmRpbmdOdW0pIC8gX3JvdW5kaW5nTnVtIHx8IChwcm9ncmVzcyA8IDAgPyAwIDogMSk7XG5cdH0sXG5cdCAgICBfcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcblx0ICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIF9yb3VuZGluZ051bSkgLyBfcm91bmRpbmdOdW0gfHwgMDtcblx0fSxcblx0ICAgIF9yb3VuZFByZWNpc2UgPSBmdW5jdGlvbiBfcm91bmRQcmVjaXNlKHZhbHVlKSB7XG5cdCAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxZTEwKSAvIDFlMTAgfHwgMDtcblx0fSxcblx0ICAgIF9zcGxpdFNlZ21lbnQgPSBmdW5jdGlvbiBfc3BsaXRTZWdtZW50KHJhd1BhdGgsIHNlZ0luZGV4LCBpLCB0KSB7XG5cdCAgdmFyIHNlZ21lbnQgPSByYXdQYXRoW3NlZ0luZGV4XSxcblx0ICAgICAgc2hpZnQgPSB0ID09PSAxID8gNiA6IHN1YmRpdmlkZVNlZ21lbnQoc2VnbWVudCwgaSwgdCk7XG5cblx0ICBpZiAoKHNoaWZ0IHx8ICF0KSAmJiBzaGlmdCArIGkgKyAyIDwgc2VnbWVudC5sZW5ndGgpIHtcblx0ICAgIHJhd1BhdGguc3BsaWNlKHNlZ0luZGV4LCAwLCBzZWdtZW50LnNsaWNlKDAsIGkgKyBzaGlmdCArIDIpKTtcblx0ICAgIHNlZ21lbnQuc3BsaWNlKDAsIGkgKyBzaGlmdCk7XG5cdCAgICByZXR1cm4gMTtcblx0ICB9XG5cdH0sXG5cdCAgICBfZ2V0U2FtcGxlSW5kZXggPSBmdW5jdGlvbiBfZ2V0U2FtcGxlSW5kZXgoc2FtcGxlcywgbGVuZ3RoLCBwcm9ncmVzcykge1xuXHQgIHZhciBsID0gc2FtcGxlcy5sZW5ndGgsXG5cdCAgICAgIGkgPSB+fihwcm9ncmVzcyAqIGwpO1xuXG5cdCAgaWYgKHNhbXBsZXNbaV0gPiBsZW5ndGgpIHtcblx0ICAgIHdoaWxlICgtLWkgJiYgc2FtcGxlc1tpXSA+IGxlbmd0aCkge31cblxuXHQgICAgaSA8IDAgJiYgKGkgPSAwKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgd2hpbGUgKHNhbXBsZXNbKytpXSA8IGxlbmd0aCAmJiBpIDwgbCkge31cblx0ICB9XG5cblx0ICByZXR1cm4gaSA8IGwgPyBpIDogbCAtIDE7XG5cdH0sXG5cdCAgICBfcmV2ZXJzZVJhd1BhdGggPSBmdW5jdGlvbiBfcmV2ZXJzZVJhd1BhdGgocmF3UGF0aCwgc2tpcE91dGVyKSB7XG5cdCAgdmFyIGkgPSByYXdQYXRoLmxlbmd0aDtcblx0ICBza2lwT3V0ZXIgfHwgcmF3UGF0aC5yZXZlcnNlKCk7XG5cblx0ICB3aGlsZSAoaS0tKSB7XG5cdCAgICByYXdQYXRoW2ldLnJldmVyc2VkIHx8IHJldmVyc2VTZWdtZW50KHJhd1BhdGhbaV0pO1xuXHQgIH1cblx0fSxcblx0ICAgIF9jb3B5TWV0YURhdGEgPSBmdW5jdGlvbiBfY29weU1ldGFEYXRhKHNvdXJjZSwgY29weSkge1xuXHQgIGNvcHkudG90YWxMZW5ndGggPSBzb3VyY2UudG90YWxMZW5ndGg7XG5cblx0ICBpZiAoc291cmNlLnNhbXBsZXMpIHtcblx0ICAgIGNvcHkuc2FtcGxlcyA9IHNvdXJjZS5zYW1wbGVzLnNsaWNlKDApO1xuXHQgICAgY29weS5sb29rdXAgPSBzb3VyY2UubG9va3VwLnNsaWNlKDApO1xuXHQgICAgY29weS5taW5MZW5ndGggPSBzb3VyY2UubWluTGVuZ3RoO1xuXHQgICAgY29weS5yZXNvbHV0aW9uID0gc291cmNlLnJlc29sdXRpb247XG5cdCAgfSBlbHNlIGlmIChzb3VyY2UudG90YWxQb2ludHMpIHtcblx0ICAgIGNvcHkudG90YWxQb2ludHMgPSBzb3VyY2UudG90YWxQb2ludHM7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGNvcHk7XG5cdH0sXG5cdCAgICBfYXBwZW5kT3JNZXJnZSA9IGZ1bmN0aW9uIF9hcHBlbmRPck1lcmdlKHJhd1BhdGgsIHNlZ21lbnQpIHtcblx0ICB2YXIgaW5kZXggPSByYXdQYXRoLmxlbmd0aCxcblx0ICAgICAgcHJldlNlZyA9IHJhd1BhdGhbaW5kZXggLSAxXSB8fCBbXSxcblx0ICAgICAgbCA9IHByZXZTZWcubGVuZ3RoO1xuXG5cdCAgaWYgKGluZGV4ICYmIHNlZ21lbnRbMF0gPT09IHByZXZTZWdbbCAtIDJdICYmIHNlZ21lbnRbMV0gPT09IHByZXZTZWdbbCAtIDFdKSB7XG5cdCAgICBzZWdtZW50ID0gcHJldlNlZy5jb25jYXQoc2VnbWVudC5zbGljZSgyKSk7XG5cdCAgICBpbmRleC0tO1xuXHQgIH1cblxuXHQgIHJhd1BhdGhbaW5kZXhdID0gc2VnbWVudDtcblx0fTtcblxuXHRmdW5jdGlvbiBnZXRSYXdQYXRoKHZhbHVlKSB7XG5cdCAgdmFsdWUgPSBfaXNTdHJpbmcodmFsdWUpICYmIF9zZWxlY3RvckV4cC50ZXN0KHZhbHVlKSA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodmFsdWUpIHx8IHZhbHVlIDogdmFsdWU7XG5cdCAgdmFyIGUgPSB2YWx1ZS5nZXRBdHRyaWJ1dGUgPyB2YWx1ZSA6IDAsXG5cdCAgICAgIHJhd1BhdGg7XG5cblx0ICBpZiAoZSAmJiAodmFsdWUgPSB2YWx1ZS5nZXRBdHRyaWJ1dGUoXCJkXCIpKSkge1xuXHQgICAgaWYgKCFlLl9nc1BhdGgpIHtcblx0ICAgICAgZS5fZ3NQYXRoID0ge307XG5cdCAgICB9XG5cblx0ICAgIHJhd1BhdGggPSBlLl9nc1BhdGhbdmFsdWVdO1xuXHQgICAgcmV0dXJuIHJhd1BhdGggJiYgIXJhd1BhdGguX2RpcnR5ID8gcmF3UGF0aCA6IGUuX2dzUGF0aFt2YWx1ZV0gPSBzdHJpbmdUb1Jhd1BhdGgodmFsdWUpO1xuXHQgIH1cblxuXHQgIHJldHVybiAhdmFsdWUgPyBjb25zb2xlLndhcm4oXCJFeHBlY3RpbmcgYSA8cGF0aD4gZWxlbWVudCBvciBhbiBTVkcgcGF0aCBkYXRhIHN0cmluZ1wiKSA6IF9pc1N0cmluZyh2YWx1ZSkgPyBzdHJpbmdUb1Jhd1BhdGgodmFsdWUpIDogX2lzTnVtYmVyKHZhbHVlWzBdKSA/IFt2YWx1ZV0gOiB2YWx1ZTtcblx0fVxuXHRmdW5jdGlvbiBjb3B5UmF3UGF0aChyYXdQYXRoKSB7XG5cdCAgdmFyIGEgPSBbXSxcblx0ICAgICAgaSA9IDA7XG5cblx0ICBmb3IgKDsgaSA8IHJhd1BhdGgubGVuZ3RoOyBpKyspIHtcblx0ICAgIGFbaV0gPSBfY29weU1ldGFEYXRhKHJhd1BhdGhbaV0sIHJhd1BhdGhbaV0uc2xpY2UoMCkpO1xuXHQgIH1cblxuXHQgIHJldHVybiBfY29weU1ldGFEYXRhKHJhd1BhdGgsIGEpO1xuXHR9XG5cdGZ1bmN0aW9uIHJldmVyc2VTZWdtZW50KHNlZ21lbnQpIHtcblx0ICB2YXIgaSA9IDAsXG5cdCAgICAgIHk7XG5cdCAgc2VnbWVudC5yZXZlcnNlKCk7XG5cblx0ICBmb3IgKDsgaSA8IHNlZ21lbnQubGVuZ3RoOyBpICs9IDIpIHtcblx0ICAgIHkgPSBzZWdtZW50W2ldO1xuXHQgICAgc2VnbWVudFtpXSA9IHNlZ21lbnRbaSArIDFdO1xuXHQgICAgc2VnbWVudFtpICsgMV0gPSB5O1xuXHQgIH1cblxuXHQgIHNlZ21lbnQucmV2ZXJzZWQgPSAhc2VnbWVudC5yZXZlcnNlZDtcblx0fVxuXG5cdHZhciBfY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIF9jcmVhdGVQYXRoKGUsIGlnbm9yZSkge1xuXHQgIHZhciBwYXRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJwYXRoXCIpLFxuXHQgICAgICBhdHRyID0gW10uc2xpY2UuY2FsbChlLmF0dHJpYnV0ZXMpLFxuXHQgICAgICBpID0gYXR0ci5sZW5ndGgsXG5cdCAgICAgIG5hbWU7XG5cdCAgaWdub3JlID0gXCIsXCIgKyBpZ25vcmUgKyBcIixcIjtcblxuXHQgIHdoaWxlICgtLWkgPiAtMSkge1xuXHQgICAgbmFtZSA9IGF0dHJbaV0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQgICAgaWYgKGlnbm9yZS5pbmRleE9mKFwiLFwiICsgbmFtZSArIFwiLFwiKSA8IDApIHtcblx0ICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBuYW1lLCBhdHRyW2ldLm5vZGVWYWx1ZSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHBhdGg7XG5cdH0sXG5cdCAgICBfdHlwZUF0dHJzID0ge1xuXHQgIHJlY3Q6IFwicngscnkseCx5LHdpZHRoLGhlaWdodFwiLFxuXHQgIGNpcmNsZTogXCJyLGN4LGN5XCIsXG5cdCAgZWxsaXBzZTogXCJyeCxyeSxjeCxjeVwiLFxuXHQgIGxpbmU6IFwieDEseDIseTEseTJcIlxuXHR9LFxuXHQgICAgX2F0dHJUb09iaiA9IGZ1bmN0aW9uIF9hdHRyVG9PYmooZSwgYXR0cnMpIHtcblx0ICB2YXIgcHJvcHMgPSBhdHRycyA/IGF0dHJzLnNwbGl0KFwiLFwiKSA6IFtdLFxuXHQgICAgICBvYmogPSB7fSxcblx0ICAgICAgaSA9IHByb3BzLmxlbmd0aDtcblxuXHQgIHdoaWxlICgtLWkgPiAtMSkge1xuXHQgICAgb2JqW3Byb3BzW2ldXSA9ICtlLmdldEF0dHJpYnV0ZShwcm9wc1tpXSkgfHwgMDtcblx0ICB9XG5cblx0ICByZXR1cm4gb2JqO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGNvbnZlcnRUb1BhdGgoZWxlbWVudCwgc3dhcCkge1xuXHQgIHZhciB0eXBlID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCksXG5cdCAgICAgIGNpcmMgPSAwLjU1MjI4NDc0OTgzMSxcblx0ICAgICAgZGF0YSxcblx0ICAgICAgeCxcblx0ICAgICAgeSxcblx0ICAgICAgcixcblx0ICAgICAgcnksXG5cdCAgICAgIHBhdGgsXG5cdCAgICAgIHJjaXJjLFxuXHQgICAgICByeWNpcmMsXG5cdCAgICAgIHBvaW50cyxcblx0ICAgICAgdyxcblx0ICAgICAgaCxcblx0ICAgICAgeDIsXG5cdCAgICAgIHgzLFxuXHQgICAgICB4NCxcblx0ICAgICAgeDUsXG5cdCAgICAgIHg2LFxuXHQgICAgICB5Mixcblx0ICAgICAgeTMsXG5cdCAgICAgIHk0LFxuXHQgICAgICB5NSxcblx0ICAgICAgeTYsXG5cdCAgICAgIGF0dHI7XG5cblx0ICBpZiAodHlwZSA9PT0gXCJwYXRoXCIgfHwgIWVsZW1lbnQuZ2V0QkJveCkge1xuXHQgICAgcmV0dXJuIGVsZW1lbnQ7XG5cdCAgfVxuXG5cdCAgcGF0aCA9IF9jcmVhdGVQYXRoKGVsZW1lbnQsIFwieCx5LHdpZHRoLGhlaWdodCxjeCxjeSxyeCxyeSxyLHgxLHgyLHkxLHkyLHBvaW50c1wiKTtcblx0ICBhdHRyID0gX2F0dHJUb09iaihlbGVtZW50LCBfdHlwZUF0dHJzW3R5cGVdKTtcblxuXHQgIGlmICh0eXBlID09PSBcInJlY3RcIikge1xuXHQgICAgciA9IGF0dHIucng7XG5cdCAgICByeSA9IGF0dHIucnkgfHwgcjtcblx0ICAgIHggPSBhdHRyLng7XG5cdCAgICB5ID0gYXR0ci55O1xuXHQgICAgdyA9IGF0dHIud2lkdGggLSByICogMjtcblx0ICAgIGggPSBhdHRyLmhlaWdodCAtIHJ5ICogMjtcblxuXHQgICAgaWYgKHIgfHwgcnkpIHtcblx0ICAgICAgeDIgPSB4ICsgciAqICgxIC0gY2lyYyk7XG5cdCAgICAgIHgzID0geCArIHI7XG5cdCAgICAgIHg0ID0geDMgKyB3O1xuXHQgICAgICB4NSA9IHg0ICsgciAqIGNpcmM7XG5cdCAgICAgIHg2ID0geDQgKyByO1xuXHQgICAgICB5MiA9IHkgKyByeSAqICgxIC0gY2lyYyk7XG5cdCAgICAgIHkzID0geSArIHJ5O1xuXHQgICAgICB5NCA9IHkzICsgaDtcblx0ICAgICAgeTUgPSB5NCArIHJ5ICogY2lyYztcblx0ICAgICAgeTYgPSB5NCArIHJ5O1xuXHQgICAgICBkYXRhID0gXCJNXCIgKyB4NiArIFwiLFwiICsgeTMgKyBcIiBWXCIgKyB5NCArIFwiIENcIiArIFt4NiwgeTUsIHg1LCB5NiwgeDQsIHk2LCB4NCAtICh4NCAtIHgzKSAvIDMsIHk2LCB4MyArICh4NCAtIHgzKSAvIDMsIHk2LCB4MywgeTYsIHgyLCB5NiwgeCwgeTUsIHgsIHk0LCB4LCB5NCAtICh5NCAtIHkzKSAvIDMsIHgsIHkzICsgKHk0IC0geTMpIC8gMywgeCwgeTMsIHgsIHkyLCB4MiwgeSwgeDMsIHksIHgzICsgKHg0IC0geDMpIC8gMywgeSwgeDQgLSAoeDQgLSB4MykgLyAzLCB5LCB4NCwgeSwgeDUsIHksIHg2LCB5MiwgeDYsIHkzXS5qb2luKFwiLFwiKSArIFwielwiO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZGF0YSA9IFwiTVwiICsgKHggKyB3KSArIFwiLFwiICsgeSArIFwiIHZcIiArIGggKyBcIiBoXCIgKyAtdyArIFwiIHZcIiArIC1oICsgXCIgaFwiICsgdyArIFwielwiO1xuXHQgICAgfVxuXHQgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjaXJjbGVcIiB8fCB0eXBlID09PSBcImVsbGlwc2VcIikge1xuXHQgICAgaWYgKHR5cGUgPT09IFwiY2lyY2xlXCIpIHtcblx0ICAgICAgciA9IHJ5ID0gYXR0ci5yO1xuXHQgICAgICByeWNpcmMgPSByICogY2lyYztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHIgPSBhdHRyLnJ4O1xuXHQgICAgICByeSA9IGF0dHIucnk7XG5cdCAgICAgIHJ5Y2lyYyA9IHJ5ICogY2lyYztcblx0ICAgIH1cblxuXHQgICAgeCA9IGF0dHIuY3g7XG5cdCAgICB5ID0gYXR0ci5jeTtcblx0ICAgIHJjaXJjID0gciAqIGNpcmM7XG5cdCAgICBkYXRhID0gXCJNXCIgKyAoeCArIHIpICsgXCIsXCIgKyB5ICsgXCIgQ1wiICsgW3ggKyByLCB5ICsgcnljaXJjLCB4ICsgcmNpcmMsIHkgKyByeSwgeCwgeSArIHJ5LCB4IC0gcmNpcmMsIHkgKyByeSwgeCAtIHIsIHkgKyByeWNpcmMsIHggLSByLCB5LCB4IC0gciwgeSAtIHJ5Y2lyYywgeCAtIHJjaXJjLCB5IC0gcnksIHgsIHkgLSByeSwgeCArIHJjaXJjLCB5IC0gcnksIHggKyByLCB5IC0gcnljaXJjLCB4ICsgciwgeV0uam9pbihcIixcIikgKyBcInpcIjtcblx0ICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibGluZVwiKSB7XG5cdCAgICBkYXRhID0gXCJNXCIgKyBhdHRyLngxICsgXCIsXCIgKyBhdHRyLnkxICsgXCIgTFwiICsgYXR0ci54MiArIFwiLFwiICsgYXR0ci55Mjtcblx0ICB9IGVsc2UgaWYgKHR5cGUgPT09IFwicG9seWxpbmVcIiB8fCB0eXBlID09PSBcInBvbHlnb25cIikge1xuXHQgICAgcG9pbnRzID0gKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwicG9pbnRzXCIpICsgXCJcIikubWF0Y2goX251bWJlcnNFeHApIHx8IFtdO1xuXHQgICAgeCA9IHBvaW50cy5zaGlmdCgpO1xuXHQgICAgeSA9IHBvaW50cy5zaGlmdCgpO1xuXHQgICAgZGF0YSA9IFwiTVwiICsgeCArIFwiLFwiICsgeSArIFwiIExcIiArIHBvaW50cy5qb2luKFwiLFwiKTtcblxuXHQgICAgaWYgKHR5cGUgPT09IFwicG9seWdvblwiKSB7XG5cdCAgICAgIGRhdGEgKz0gXCIsXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCJ6XCI7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJkXCIsIHJhd1BhdGhUb1N0cmluZyhwYXRoLl9nc1Jhd1BhdGggPSBzdHJpbmdUb1Jhd1BhdGgoZGF0YSkpKTtcblxuXHQgIGlmIChzd2FwICYmIGVsZW1lbnQucGFyZW50Tm9kZSkge1xuXHQgICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShwYXRoLCBlbGVtZW50KTtcblx0ICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcblx0ICB9XG5cblx0ICByZXR1cm4gcGF0aDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFJvdGF0aW9uQXRCZXppZXJUKHNlZ21lbnQsIGksIHQpIHtcblx0ICB2YXIgYSA9IHNlZ21lbnRbaV0sXG5cdCAgICAgIGIgPSBzZWdtZW50W2kgKyAyXSxcblx0ICAgICAgYyA9IHNlZ21lbnRbaSArIDRdLFxuXHQgICAgICB4O1xuXHQgIGEgKz0gKGIgLSBhKSAqIHQ7XG5cdCAgYiArPSAoYyAtIGIpICogdDtcblx0ICBhICs9IChiIC0gYSkgKiB0O1xuXHQgIHggPSBiICsgKGMgKyAoc2VnbWVudFtpICsgNl0gLSBjKSAqIHQgLSBiKSAqIHQgLSBhO1xuXHQgIGEgPSBzZWdtZW50W2kgKyAxXTtcblx0ICBiID0gc2VnbWVudFtpICsgM107XG5cdCAgYyA9IHNlZ21lbnRbaSArIDVdO1xuXHQgIGEgKz0gKGIgLSBhKSAqIHQ7XG5cdCAgYiArPSAoYyAtIGIpICogdDtcblx0ICBhICs9IChiIC0gYSkgKiB0O1xuXHQgIHJldHVybiBfcm91bmQoX2F0YW4yKGIgKyAoYyArIChzZWdtZW50W2kgKyA3XSAtIGMpICogdCAtIGIpICogdCAtIGEsIHgpICogX1JBRDJERUcpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2xpY2VSYXdQYXRoKHJhd1BhdGgsIHN0YXJ0LCBlbmQpIHtcblx0ICBlbmQgPSBfaXNVbmRlZmluZWQoZW5kKSA/IDEgOiBfcm91bmRQcmVjaXNlKGVuZCkgfHwgMDtcblx0ICBzdGFydCA9IF9yb3VuZFByZWNpc2Uoc3RhcnQpIHx8IDA7XG5cdCAgdmFyIGxvb3BzID0gTWF0aC5tYXgoMCwgfn4oX2FicyhlbmQgLSBzdGFydCkgLSAxZS04KSksXG5cdCAgICAgIHBhdGggPSBjb3B5UmF3UGF0aChyYXdQYXRoKTtcblxuXHQgIGlmIChzdGFydCA+IGVuZCkge1xuXHQgICAgc3RhcnQgPSAxIC0gc3RhcnQ7XG5cdCAgICBlbmQgPSAxIC0gZW5kO1xuXG5cdCAgICBfcmV2ZXJzZVJhd1BhdGgocGF0aCk7XG5cblx0ICAgIHBhdGgudG90YWxMZW5ndGggPSAwO1xuXHQgIH1cblxuXHQgIGlmIChzdGFydCA8IDAgfHwgZW5kIDwgMCkge1xuXHQgICAgdmFyIG9mZnNldCA9IE1hdGguYWJzKH5+TWF0aC5taW4oc3RhcnQsIGVuZCkpICsgMTtcblx0ICAgIHN0YXJ0ICs9IG9mZnNldDtcblx0ICAgIGVuZCArPSBvZmZzZXQ7XG5cdCAgfVxuXG5cdCAgcGF0aC50b3RhbExlbmd0aCB8fCBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMocGF0aCk7XG5cdCAgdmFyIHdyYXAgPSBlbmQgPiAxLFxuXHQgICAgICBzID0gZ2V0UHJvZ3Jlc3NEYXRhKHBhdGgsIHN0YXJ0LCBfdGVtcCwgdHJ1ZSksXG5cdCAgICAgIGUgPSBnZXRQcm9ncmVzc0RhdGEocGF0aCwgZW5kLCBfdGVtcDIpLFxuXHQgICAgICBlU2VnID0gZS5zZWdtZW50LFxuXHQgICAgICBzU2VnID0gcy5zZWdtZW50LFxuXHQgICAgICBlU2VnSW5kZXggPSBlLnNlZ0luZGV4LFxuXHQgICAgICBzU2VnSW5kZXggPSBzLnNlZ0luZGV4LFxuXHQgICAgICBlaSA9IGUuaSxcblx0ICAgICAgc2kgPSBzLmksXG5cdCAgICAgIHNhbWVTZWdtZW50ID0gc1NlZ0luZGV4ID09PSBlU2VnSW5kZXgsXG5cdCAgICAgIHNhbWVCZXppZXIgPSBlaSA9PT0gc2kgJiYgc2FtZVNlZ21lbnQsXG5cdCAgICAgIHdyYXBzQmVoaW5kLFxuXHQgICAgICBzU2hpZnQsXG5cdCAgICAgIGVTaGlmdCxcblx0ICAgICAgaSxcblx0ICAgICAgY29weSxcblx0ICAgICAgdG90YWxTZWdtZW50cyxcblx0ICAgICAgbCxcblx0ICAgICAgajtcblxuXHQgIGlmICh3cmFwIHx8IGxvb3BzKSB7XG5cdCAgICB3cmFwc0JlaGluZCA9IGVTZWdJbmRleCA8IHNTZWdJbmRleCB8fCBzYW1lU2VnbWVudCAmJiBlaSA8IHNpIHx8IHNhbWVCZXppZXIgJiYgZS50IDwgcy50O1xuXG5cdCAgICBpZiAoX3NwbGl0U2VnbWVudChwYXRoLCBzU2VnSW5kZXgsIHNpLCBzLnQpKSB7XG5cdCAgICAgIHNTZWdJbmRleCsrO1xuXG5cdCAgICAgIGlmICghd3JhcHNCZWhpbmQpIHtcblx0ICAgICAgICBlU2VnSW5kZXgrKztcblxuXHQgICAgICAgIGlmIChzYW1lQmV6aWVyKSB7XG5cdCAgICAgICAgICBlLnQgPSAoZS50IC0gcy50KSAvICgxIC0gcy50KTtcblx0ICAgICAgICAgIGVpID0gMDtcblx0ICAgICAgICB9IGVsc2UgaWYgKHNhbWVTZWdtZW50KSB7XG5cdCAgICAgICAgICBlaSAtPSBzaTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKE1hdGguYWJzKDEgLSAoZW5kIC0gc3RhcnQpKSA8IDFlLTUpIHtcblx0ICAgICAgZVNlZ0luZGV4ID0gc1NlZ0luZGV4IC0gMTtcblx0ICAgIH0gZWxzZSBpZiAoIWUudCAmJiBlU2VnSW5kZXgpIHtcblx0ICAgICAgZVNlZ0luZGV4LS07XG5cdCAgICB9IGVsc2UgaWYgKF9zcGxpdFNlZ21lbnQocGF0aCwgZVNlZ0luZGV4LCBlaSwgZS50KSAmJiB3cmFwc0JlaGluZCkge1xuXHQgICAgICBzU2VnSW5kZXgrKztcblx0ICAgIH1cblxuXHQgICAgaWYgKHMudCA9PT0gMSkge1xuXHQgICAgICBzU2VnSW5kZXggPSAoc1NlZ0luZGV4ICsgMSkgJSBwYXRoLmxlbmd0aDtcblx0ICAgIH1cblxuXHQgICAgY29weSA9IFtdO1xuXHQgICAgdG90YWxTZWdtZW50cyA9IHBhdGgubGVuZ3RoO1xuXHQgICAgbCA9IDEgKyB0b3RhbFNlZ21lbnRzICogbG9vcHM7XG5cdCAgICBqID0gc1NlZ0luZGV4O1xuXHQgICAgbCArPSAodG90YWxTZWdtZW50cyAtIHNTZWdJbmRleCArIGVTZWdJbmRleCkgJSB0b3RhbFNlZ21lbnRzO1xuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdCAgICAgIF9hcHBlbmRPck1lcmdlKGNvcHksIHBhdGhbaisrICUgdG90YWxTZWdtZW50c10pO1xuXHQgICAgfVxuXG5cdCAgICBwYXRoID0gY29weTtcblx0ICB9IGVsc2Uge1xuXHQgICAgZVNoaWZ0ID0gZS50ID09PSAxID8gNiA6IHN1YmRpdmlkZVNlZ21lbnQoZVNlZywgZWksIGUudCk7XG5cblx0ICAgIGlmIChzdGFydCAhPT0gZW5kKSB7XG5cdCAgICAgIHNTaGlmdCA9IHN1YmRpdmlkZVNlZ21lbnQoc1NlZywgc2ksIHNhbWVCZXppZXIgPyBzLnQgLyBlLnQgOiBzLnQpO1xuXHQgICAgICBzYW1lU2VnbWVudCAmJiAoZVNoaWZ0ICs9IHNTaGlmdCk7XG5cdCAgICAgIGVTZWcuc3BsaWNlKGVpICsgZVNoaWZ0ICsgMik7XG5cdCAgICAgIChzU2hpZnQgfHwgc2kpICYmIHNTZWcuc3BsaWNlKDAsIHNpICsgc1NoaWZ0KTtcblx0ICAgICAgaSA9IHBhdGgubGVuZ3RoO1xuXG5cdCAgICAgIHdoaWxlIChpLS0pIHtcblx0ICAgICAgICAoaSA8IHNTZWdJbmRleCB8fCBpID4gZVNlZ0luZGV4KSAmJiBwYXRoLnNwbGljZShpLCAxKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZVNlZy5hbmdsZSA9IGdldFJvdGF0aW9uQXRCZXppZXJUKGVTZWcsIGVpICsgZVNoaWZ0LCAwKTtcblx0ICAgICAgZWkgKz0gZVNoaWZ0O1xuXHQgICAgICBzID0gZVNlZ1tlaV07XG5cdCAgICAgIGUgPSBlU2VnW2VpICsgMV07XG5cdCAgICAgIGVTZWcubGVuZ3RoID0gZVNlZy50b3RhbExlbmd0aCA9IDA7XG5cdCAgICAgIGVTZWcudG90YWxQb2ludHMgPSBwYXRoLnRvdGFsUG9pbnRzID0gODtcblx0ICAgICAgZVNlZy5wdXNoKHMsIGUsIHMsIGUsIHMsIGUsIHMsIGUpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHBhdGgudG90YWxMZW5ndGggPSAwO1xuXHQgIHJldHVybiBwYXRoO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWVhc3VyZVNlZ21lbnQoc2VnbWVudCwgc3RhcnRJbmRleCwgYmV6aWVyUXR5KSB7XG5cdCAgc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXggfHwgMDtcblxuXHQgIGlmICghc2VnbWVudC5zYW1wbGVzKSB7XG5cdCAgICBzZWdtZW50LnNhbXBsZXMgPSBbXTtcblx0ICAgIHNlZ21lbnQubG9va3VwID0gW107XG5cdCAgfVxuXG5cdCAgdmFyIHJlc29sdXRpb24gPSB+fnNlZ21lbnQucmVzb2x1dGlvbiB8fCAxMixcblx0ICAgICAgaW5jID0gMSAvIHJlc29sdXRpb24sXG5cdCAgICAgIGVuZEluZGV4ID0gYmV6aWVyUXR5ID8gc3RhcnRJbmRleCArIGJlemllclF0eSAqIDYgKyAxIDogc2VnbWVudC5sZW5ndGgsXG5cdCAgICAgIHgxID0gc2VnbWVudFtzdGFydEluZGV4XSxcblx0ICAgICAgeTEgPSBzZWdtZW50W3N0YXJ0SW5kZXggKyAxXSxcblx0ICAgICAgc2FtcGxlc0luZGV4ID0gc3RhcnRJbmRleCA/IHN0YXJ0SW5kZXggLyA2ICogcmVzb2x1dGlvbiA6IDAsXG5cdCAgICAgIHNhbXBsZXMgPSBzZWdtZW50LnNhbXBsZXMsXG5cdCAgICAgIGxvb2t1cCA9IHNlZ21lbnQubG9va3VwLFxuXHQgICAgICBtaW4gPSAoc3RhcnRJbmRleCA/IHNlZ21lbnQubWluTGVuZ3RoIDogX2xhcmdlTnVtKSB8fCBfbGFyZ2VOdW0sXG5cdCAgICAgIHByZXZMZW5ndGggPSBzYW1wbGVzW3NhbXBsZXNJbmRleCArIGJlemllclF0eSAqIHJlc29sdXRpb24gLSAxXSxcblx0ICAgICAgbGVuZ3RoID0gc3RhcnRJbmRleCA/IHNhbXBsZXNbc2FtcGxlc0luZGV4IC0gMV0gOiAwLFxuXHQgICAgICBpLFxuXHQgICAgICBqLFxuXHQgICAgICB4NCxcblx0ICAgICAgeDMsXG5cdCAgICAgIHgyLFxuXHQgICAgICB4ZCxcblx0ICAgICAgeGQxLFxuXHQgICAgICB5NCxcblx0ICAgICAgeTMsXG5cdCAgICAgIHkyLFxuXHQgICAgICB5ZCxcblx0ICAgICAgeWQxLFxuXHQgICAgICBpbnYsXG5cdCAgICAgIHQsXG5cdCAgICAgIGxlbmd0aEluZGV4LFxuXHQgICAgICBsLFxuXHQgICAgICBzZWdMZW5ndGg7XG5cdCAgc2FtcGxlcy5sZW5ndGggPSBsb29rdXAubGVuZ3RoID0gMDtcblxuXHQgIGZvciAoaiA9IHN0YXJ0SW5kZXggKyAyOyBqIDwgZW5kSW5kZXg7IGogKz0gNikge1xuXHQgICAgeDQgPSBzZWdtZW50W2ogKyA0XSAtIHgxO1xuXHQgICAgeDMgPSBzZWdtZW50W2ogKyAyXSAtIHgxO1xuXHQgICAgeDIgPSBzZWdtZW50W2pdIC0geDE7XG5cdCAgICB5NCA9IHNlZ21lbnRbaiArIDVdIC0geTE7XG5cdCAgICB5MyA9IHNlZ21lbnRbaiArIDNdIC0geTE7XG5cdCAgICB5MiA9IHNlZ21lbnRbaiArIDFdIC0geTE7XG5cdCAgICB4ZCA9IHhkMSA9IHlkID0geWQxID0gMDtcblxuXHQgICAgaWYgKF9hYnMoeDQpIDwgLjAxICYmIF9hYnMoeTQpIDwgLjAxICYmIF9hYnMoeDIpICsgX2Ficyh5MikgPCAuMDEpIHtcblx0ICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gOCkge1xuXHQgICAgICAgIHNlZ21lbnQuc3BsaWNlKGosIDYpO1xuXHQgICAgICAgIGogLT0gNjtcblx0ICAgICAgICBlbmRJbmRleCAtPSA2O1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBmb3IgKGkgPSAxOyBpIDw9IHJlc29sdXRpb247IGkrKykge1xuXHQgICAgICAgIHQgPSBpbmMgKiBpO1xuXHQgICAgICAgIGludiA9IDEgLSB0O1xuXHQgICAgICAgIHhkID0geGQxIC0gKHhkMSA9ICh0ICogdCAqIHg0ICsgMyAqIGludiAqICh0ICogeDMgKyBpbnYgKiB4MikpICogdCk7XG5cdCAgICAgICAgeWQgPSB5ZDEgLSAoeWQxID0gKHQgKiB0ICogeTQgKyAzICogaW52ICogKHQgKiB5MyArIGludiAqIHkyKSkgKiB0KTtcblx0ICAgICAgICBsID0gX3NxcnQoeWQgKiB5ZCArIHhkICogeGQpO1xuXG5cdCAgICAgICAgaWYgKGwgPCBtaW4pIHtcblx0ICAgICAgICAgIG1pbiA9IGw7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgbGVuZ3RoICs9IGw7XG5cdCAgICAgICAgc2FtcGxlc1tzYW1wbGVzSW5kZXgrK10gPSBsZW5ndGg7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgeDEgKz0geDQ7XG5cdCAgICB5MSArPSB5NDtcblx0ICB9XG5cblx0ICBpZiAocHJldkxlbmd0aCkge1xuXHQgICAgcHJldkxlbmd0aCAtPSBsZW5ndGg7XG5cblx0ICAgIGZvciAoOyBzYW1wbGVzSW5kZXggPCBzYW1wbGVzLmxlbmd0aDsgc2FtcGxlc0luZGV4KyspIHtcblx0ICAgICAgc2FtcGxlc1tzYW1wbGVzSW5kZXhdICs9IHByZXZMZW5ndGg7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKHNhbXBsZXMubGVuZ3RoICYmIG1pbikge1xuXHQgICAgc2VnbWVudC50b3RhbExlbmd0aCA9IHNlZ0xlbmd0aCA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGggLSAxXSB8fCAwO1xuXHQgICAgc2VnbWVudC5taW5MZW5ndGggPSBtaW47XG5cblx0ICAgIGlmIChzZWdMZW5ndGggLyBtaW4gPCA5OTk5KSB7XG5cdCAgICAgIGwgPSBsZW5ndGhJbmRleCA9IDA7XG5cblx0ICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ0xlbmd0aDsgaSArPSBtaW4pIHtcblx0ICAgICAgICBsb29rdXBbbCsrXSA9IHNhbXBsZXNbbGVuZ3RoSW5kZXhdIDwgaSA/ICsrbGVuZ3RoSW5kZXggOiBsZW5ndGhJbmRleDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBzZWdtZW50LnRvdGFsTGVuZ3RoID0gc2FtcGxlc1swXSA9IDA7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHN0YXJ0SW5kZXggPyBsZW5ndGggLSBzYW1wbGVzW3N0YXJ0SW5kZXggLyAyIC0gMV0gOiBsZW5ndGg7XG5cdH1cblxuXHRmdW5jdGlvbiBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMocmF3UGF0aCwgcmVzb2x1dGlvbikge1xuXHQgIHZhciBwYXRoTGVuZ3RoLCBwb2ludHMsIGk7XG5cblx0ICBmb3IgKGkgPSBwYXRoTGVuZ3RoID0gcG9pbnRzID0gMDsgaSA8IHJhd1BhdGgubGVuZ3RoOyBpKyspIHtcblx0ICAgIHJhd1BhdGhbaV0ucmVzb2x1dGlvbiA9IH5+cmVzb2x1dGlvbiB8fCAxMjtcblx0ICAgIHBvaW50cyArPSByYXdQYXRoW2ldLmxlbmd0aDtcblx0ICAgIHBhdGhMZW5ndGggKz0gbWVhc3VyZVNlZ21lbnQocmF3UGF0aFtpXSk7XG5cdCAgfVxuXG5cdCAgcmF3UGF0aC50b3RhbFBvaW50cyA9IHBvaW50cztcblx0ICByYXdQYXRoLnRvdGFsTGVuZ3RoID0gcGF0aExlbmd0aDtcblx0ICByZXR1cm4gcmF3UGF0aDtcblx0fVxuXHRmdW5jdGlvbiBzdWJkaXZpZGVTZWdtZW50KHNlZ21lbnQsIGksIHQpIHtcblx0ICBpZiAodCA8PSAwIHx8IHQgPj0gMSkge1xuXHQgICAgcmV0dXJuIDA7XG5cdCAgfVxuXG5cdCAgdmFyIGF4ID0gc2VnbWVudFtpXSxcblx0ICAgICAgYXkgPSBzZWdtZW50W2kgKyAxXSxcblx0ICAgICAgY3AxeCA9IHNlZ21lbnRbaSArIDJdLFxuXHQgICAgICBjcDF5ID0gc2VnbWVudFtpICsgM10sXG5cdCAgICAgIGNwMnggPSBzZWdtZW50W2kgKyA0XSxcblx0ICAgICAgY3AyeSA9IHNlZ21lbnRbaSArIDVdLFxuXHQgICAgICBieCA9IHNlZ21lbnRbaSArIDZdLFxuXHQgICAgICBieSA9IHNlZ21lbnRbaSArIDddLFxuXHQgICAgICB4MWEgPSBheCArIChjcDF4IC0gYXgpICogdCxcblx0ICAgICAgeDIgPSBjcDF4ICsgKGNwMnggLSBjcDF4KSAqIHQsXG5cdCAgICAgIHkxYSA9IGF5ICsgKGNwMXkgLSBheSkgKiB0LFxuXHQgICAgICB5MiA9IGNwMXkgKyAoY3AyeSAtIGNwMXkpICogdCxcblx0ICAgICAgeDEgPSB4MWEgKyAoeDIgLSB4MWEpICogdCxcblx0ICAgICAgeTEgPSB5MWEgKyAoeTIgLSB5MWEpICogdCxcblx0ICAgICAgeDJhID0gY3AyeCArIChieCAtIGNwMngpICogdCxcblx0ICAgICAgeTJhID0gY3AyeSArIChieSAtIGNwMnkpICogdDtcblx0ICB4MiArPSAoeDJhIC0geDIpICogdDtcblx0ICB5MiArPSAoeTJhIC0geTIpICogdDtcblx0ICBzZWdtZW50LnNwbGljZShpICsgMiwgNCwgX3JvdW5kKHgxYSksIF9yb3VuZCh5MWEpLCBfcm91bmQoeDEpLCBfcm91bmQoeTEpLCBfcm91bmQoeDEgKyAoeDIgLSB4MSkgKiB0KSwgX3JvdW5kKHkxICsgKHkyIC0geTEpICogdCksIF9yb3VuZCh4MiksIF9yb3VuZCh5MiksIF9yb3VuZCh4MmEpLCBfcm91bmQoeTJhKSk7XG5cdCAgc2VnbWVudC5zYW1wbGVzICYmIHNlZ21lbnQuc2FtcGxlcy5zcGxpY2UoaSAvIDYgKiBzZWdtZW50LnJlc29sdXRpb24gfCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcblx0ICByZXR1cm4gNjtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFByb2dyZXNzRGF0YShyYXdQYXRoLCBwcm9ncmVzcywgZGVjb3JhdGVlLCBwdXNoVG9OZXh0SWZBdEVuZCkge1xuXHQgIGRlY29yYXRlZSA9IGRlY29yYXRlZSB8fCB7fTtcblx0ICByYXdQYXRoLnRvdGFsTGVuZ3RoIHx8IGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyhyYXdQYXRoKTtcblxuXHQgIGlmIChwcm9ncmVzcyA8IDAgfHwgcHJvZ3Jlc3MgPiAxKSB7XG5cdCAgICBwcm9ncmVzcyA9IF93cmFwUHJvZ3Jlc3MocHJvZ3Jlc3MpO1xuXHQgIH1cblxuXHQgIHZhciBzZWdJbmRleCA9IDAsXG5cdCAgICAgIHNlZ21lbnQgPSByYXdQYXRoWzBdLFxuXHQgICAgICBzYW1wbGVzLFxuXHQgICAgICByZXNvbHV0aW9uLFxuXHQgICAgICBsZW5ndGgsXG5cdCAgICAgIG1pbixcblx0ICAgICAgbWF4LFxuXHQgICAgICBpLFxuXHQgICAgICB0O1xuXG5cdCAgaWYgKCFwcm9ncmVzcykge1xuXHQgICAgdCA9IGkgPSBzZWdJbmRleCA9IDA7XG5cdCAgICBzZWdtZW50ID0gcmF3UGF0aFswXTtcblx0ICB9IGVsc2UgaWYgKHByb2dyZXNzID09PSAxKSB7XG5cdCAgICB0ID0gMTtcblx0ICAgIHNlZ0luZGV4ID0gcmF3UGF0aC5sZW5ndGggLSAxO1xuXHQgICAgc2VnbWVudCA9IHJhd1BhdGhbc2VnSW5kZXhdO1xuXHQgICAgaSA9IHNlZ21lbnQubGVuZ3RoIC0gODtcblx0ICB9IGVsc2Uge1xuXHQgICAgaWYgKHJhd1BhdGgubGVuZ3RoID4gMSkge1xuXHQgICAgICBsZW5ndGggPSByYXdQYXRoLnRvdGFsTGVuZ3RoICogcHJvZ3Jlc3M7XG5cdCAgICAgIG1heCA9IGkgPSAwO1xuXG5cdCAgICAgIHdoaWxlICgobWF4ICs9IHJhd1BhdGhbaSsrXS50b3RhbExlbmd0aCkgPCBsZW5ndGgpIHtcblx0ICAgICAgICBzZWdJbmRleCA9IGk7XG5cdCAgICAgIH1cblxuXHQgICAgICBzZWdtZW50ID0gcmF3UGF0aFtzZWdJbmRleF07XG5cdCAgICAgIG1pbiA9IG1heCAtIHNlZ21lbnQudG90YWxMZW5ndGg7XG5cdCAgICAgIHByb2dyZXNzID0gKGxlbmd0aCAtIG1pbikgLyAobWF4IC0gbWluKSB8fCAwO1xuXHQgICAgfVxuXG5cdCAgICBzYW1wbGVzID0gc2VnbWVudC5zYW1wbGVzO1xuXHQgICAgcmVzb2x1dGlvbiA9IHNlZ21lbnQucmVzb2x1dGlvbjtcblx0ICAgIGxlbmd0aCA9IHNlZ21lbnQudG90YWxMZW5ndGggKiBwcm9ncmVzcztcblx0ICAgIGkgPSBzZWdtZW50Lmxvb2t1cC5sZW5ndGggPyBzZWdtZW50Lmxvb2t1cFt+fihsZW5ndGggLyBzZWdtZW50Lm1pbkxlbmd0aCldIHx8IDAgOiBfZ2V0U2FtcGxlSW5kZXgoc2FtcGxlcywgbGVuZ3RoLCBwcm9ncmVzcyk7XG5cdCAgICBtaW4gPSBpID8gc2FtcGxlc1tpIC0gMV0gOiAwO1xuXHQgICAgbWF4ID0gc2FtcGxlc1tpXTtcblxuXHQgICAgaWYgKG1heCA8IGxlbmd0aCkge1xuXHQgICAgICBtaW4gPSBtYXg7XG5cdCAgICAgIG1heCA9IHNhbXBsZXNbKytpXTtcblx0ICAgIH1cblxuXHQgICAgdCA9IDEgLyByZXNvbHV0aW9uICogKChsZW5ndGggLSBtaW4pIC8gKG1heCAtIG1pbikgKyBpICUgcmVzb2x1dGlvbik7XG5cdCAgICBpID0gfn4oaSAvIHJlc29sdXRpb24pICogNjtcblxuXHQgICAgaWYgKHB1c2hUb05leHRJZkF0RW5kICYmIHQgPT09IDEpIHtcblx0ICAgICAgaWYgKGkgKyA2IDwgc2VnbWVudC5sZW5ndGgpIHtcblx0ICAgICAgICBpICs9IDY7XG5cdCAgICAgICAgdCA9IDA7XG5cdCAgICAgIH0gZWxzZSBpZiAoc2VnSW5kZXggKyAxIDwgcmF3UGF0aC5sZW5ndGgpIHtcblx0ICAgICAgICBpID0gdCA9IDA7XG5cdCAgICAgICAgc2VnbWVudCA9IHJhd1BhdGhbKytzZWdJbmRleF07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICBkZWNvcmF0ZWUudCA9IHQ7XG5cdCAgZGVjb3JhdGVlLmkgPSBpO1xuXHQgIGRlY29yYXRlZS5wYXRoID0gcmF3UGF0aDtcblx0ICBkZWNvcmF0ZWUuc2VnbWVudCA9IHNlZ21lbnQ7XG5cdCAgZGVjb3JhdGVlLnNlZ0luZGV4ID0gc2VnSW5kZXg7XG5cdCAgcmV0dXJuIGRlY29yYXRlZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFBvc2l0aW9uT25QYXRoKHJhd1BhdGgsIHByb2dyZXNzLCBpbmNsdWRlQW5nbGUsIHBvaW50KSB7XG5cdCAgdmFyIHNlZ21lbnQgPSByYXdQYXRoWzBdLFxuXHQgICAgICByZXN1bHQgPSBwb2ludCB8fCB7fSxcblx0ICAgICAgc2FtcGxlcyxcblx0ICAgICAgcmVzb2x1dGlvbixcblx0ICAgICAgbGVuZ3RoLFxuXHQgICAgICBtaW4sXG5cdCAgICAgIG1heCxcblx0ICAgICAgaSxcblx0ICAgICAgdCxcblx0ICAgICAgYSxcblx0ICAgICAgaW52O1xuXG5cdCAgaWYgKHByb2dyZXNzIDwgMCB8fCBwcm9ncmVzcyA+IDEpIHtcblx0ICAgIHByb2dyZXNzID0gX3dyYXBQcm9ncmVzcyhwcm9ncmVzcyk7XG5cdCAgfVxuXG5cdCAgc2VnbWVudC5sb29rdXAgfHwgY2FjaGVSYXdQYXRoTWVhc3VyZW1lbnRzKHJhd1BhdGgpO1xuXG5cdCAgaWYgKHJhd1BhdGgubGVuZ3RoID4gMSkge1xuXHQgICAgbGVuZ3RoID0gcmF3UGF0aC50b3RhbExlbmd0aCAqIHByb2dyZXNzO1xuXHQgICAgbWF4ID0gaSA9IDA7XG5cblx0ICAgIHdoaWxlICgobWF4ICs9IHJhd1BhdGhbaSsrXS50b3RhbExlbmd0aCkgPCBsZW5ndGgpIHtcblx0ICAgICAgc2VnbWVudCA9IHJhd1BhdGhbaV07XG5cdCAgICB9XG5cblx0ICAgIG1pbiA9IG1heCAtIHNlZ21lbnQudG90YWxMZW5ndGg7XG5cdCAgICBwcm9ncmVzcyA9IChsZW5ndGggLSBtaW4pIC8gKG1heCAtIG1pbikgfHwgMDtcblx0ICB9XG5cblx0ICBzYW1wbGVzID0gc2VnbWVudC5zYW1wbGVzO1xuXHQgIHJlc29sdXRpb24gPSBzZWdtZW50LnJlc29sdXRpb247XG5cdCAgbGVuZ3RoID0gc2VnbWVudC50b3RhbExlbmd0aCAqIHByb2dyZXNzO1xuXHQgIGkgPSBzZWdtZW50Lmxvb2t1cC5sZW5ndGggPyBzZWdtZW50Lmxvb2t1cFtwcm9ncmVzcyA8IDEgPyB+fihsZW5ndGggLyBzZWdtZW50Lm1pbkxlbmd0aCkgOiBzZWdtZW50Lmxvb2t1cC5sZW5ndGggLSAxXSB8fCAwIDogX2dldFNhbXBsZUluZGV4KHNhbXBsZXMsIGxlbmd0aCwgcHJvZ3Jlc3MpO1xuXHQgIG1pbiA9IGkgPyBzYW1wbGVzW2kgLSAxXSA6IDA7XG5cdCAgbWF4ID0gc2FtcGxlc1tpXTtcblxuXHQgIGlmIChtYXggPCBsZW5ndGgpIHtcblx0ICAgIG1pbiA9IG1heDtcblx0ICAgIG1heCA9IHNhbXBsZXNbKytpXTtcblx0ICB9XG5cblx0ICB0ID0gMSAvIHJlc29sdXRpb24gKiAoKGxlbmd0aCAtIG1pbikgLyAobWF4IC0gbWluKSArIGkgJSByZXNvbHV0aW9uKSB8fCAwO1xuXHQgIGludiA9IDEgLSB0O1xuXHQgIGkgPSB+fihpIC8gcmVzb2x1dGlvbikgKiA2O1xuXHQgIGEgPSBzZWdtZW50W2ldO1xuXHQgIHJlc3VsdC54ID0gX3JvdW5kKCh0ICogdCAqIChzZWdtZW50W2kgKyA2XSAtIGEpICsgMyAqIGludiAqICh0ICogKHNlZ21lbnRbaSArIDRdIC0gYSkgKyBpbnYgKiAoc2VnbWVudFtpICsgMl0gLSBhKSkpICogdCArIGEpO1xuXHQgIHJlc3VsdC55ID0gX3JvdW5kKCh0ICogdCAqIChzZWdtZW50W2kgKyA3XSAtIChhID0gc2VnbWVudFtpICsgMV0pKSArIDMgKiBpbnYgKiAodCAqIChzZWdtZW50W2kgKyA1XSAtIGEpICsgaW52ICogKHNlZ21lbnRbaSArIDNdIC0gYSkpKSAqIHQgKyBhKTtcblxuXHQgIGlmIChpbmNsdWRlQW5nbGUpIHtcblx0ICAgIHJlc3VsdC5hbmdsZSA9IHNlZ21lbnQudG90YWxMZW5ndGggPyBnZXRSb3RhdGlvbkF0QmV6aWVyVChzZWdtZW50LCBpLCB0ID49IDEgPyAxIC0gMWUtOSA6IHQgPyB0IDogMWUtOSkgOiBzZWdtZW50LmFuZ2xlIHx8IDA7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRmdW5jdGlvbiB0cmFuc2Zvcm1SYXdQYXRoKHJhd1BhdGgsIGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuXHQgIHZhciBqID0gcmF3UGF0aC5sZW5ndGgsXG5cdCAgICAgIHNlZ21lbnQsXG5cdCAgICAgIGwsXG5cdCAgICAgIGksXG5cdCAgICAgIHgsXG5cdCAgICAgIHk7XG5cblx0ICB3aGlsZSAoLS1qID4gLTEpIHtcblx0ICAgIHNlZ21lbnQgPSByYXdQYXRoW2pdO1xuXHQgICAgbCA9IHNlZ21lbnQubGVuZ3RoO1xuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSAyKSB7XG5cdCAgICAgIHggPSBzZWdtZW50W2ldO1xuXHQgICAgICB5ID0gc2VnbWVudFtpICsgMV07XG5cdCAgICAgIHNlZ21lbnRbaV0gPSB4ICogYSArIHkgKiBjICsgdHg7XG5cdCAgICAgIHNlZ21lbnRbaSArIDFdID0geCAqIGIgKyB5ICogZCArIHR5O1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJhd1BhdGguX2RpcnR5ID0gMTtcblx0ICByZXR1cm4gcmF3UGF0aDtcblx0fVxuXG5cdGZ1bmN0aW9uIGFyY1RvU2VnbWVudChsYXN0WCwgbGFzdFksIHJ4LCByeSwgYW5nbGUsIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCB4LCB5KSB7XG5cdCAgaWYgKGxhc3RYID09PSB4ICYmIGxhc3RZID09PSB5KSB7XG5cdCAgICByZXR1cm47XG5cdCAgfVxuXG5cdCAgcnggPSBfYWJzKHJ4KTtcblx0ICByeSA9IF9hYnMocnkpO1xuXG5cdCAgdmFyIGFuZ2xlUmFkID0gYW5nbGUgJSAzNjAgKiBfREVHMlJBRCxcblx0ICAgICAgY29zQW5nbGUgPSBfY29zKGFuZ2xlUmFkKSxcblx0ICAgICAgc2luQW5nbGUgPSBfc2luKGFuZ2xlUmFkKSxcblx0ICAgICAgUEkgPSBNYXRoLlBJLFxuXHQgICAgICBUV09QSSA9IFBJICogMixcblx0ICAgICAgZHgyID0gKGxhc3RYIC0geCkgLyAyLFxuXHQgICAgICBkeTIgPSAobGFzdFkgLSB5KSAvIDIsXG5cdCAgICAgIHgxID0gY29zQW5nbGUgKiBkeDIgKyBzaW5BbmdsZSAqIGR5Mixcblx0ICAgICAgeTEgPSAtc2luQW5nbGUgKiBkeDIgKyBjb3NBbmdsZSAqIGR5Mixcblx0ICAgICAgeDFfc3EgPSB4MSAqIHgxLFxuXHQgICAgICB5MV9zcSA9IHkxICogeTEsXG5cdCAgICAgIHJhZGlpQ2hlY2sgPSB4MV9zcSAvIChyeCAqIHJ4KSArIHkxX3NxIC8gKHJ5ICogcnkpO1xuXG5cdCAgaWYgKHJhZGlpQ2hlY2sgPiAxKSB7XG5cdCAgICByeCA9IF9zcXJ0KHJhZGlpQ2hlY2spICogcng7XG5cdCAgICByeSA9IF9zcXJ0KHJhZGlpQ2hlY2spICogcnk7XG5cdCAgfVxuXG5cdCAgdmFyIHJ4X3NxID0gcnggKiByeCxcblx0ICAgICAgcnlfc3EgPSByeSAqIHJ5LFxuXHQgICAgICBzcSA9IChyeF9zcSAqIHJ5X3NxIC0gcnhfc3EgKiB5MV9zcSAtIHJ5X3NxICogeDFfc3EpIC8gKHJ4X3NxICogeTFfc3EgKyByeV9zcSAqIHgxX3NxKTtcblxuXHQgIGlmIChzcSA8IDApIHtcblx0ICAgIHNxID0gMDtcblx0ICB9XG5cblx0ICB2YXIgY29lZiA9IChsYXJnZUFyY0ZsYWcgPT09IHN3ZWVwRmxhZyA/IC0xIDogMSkgKiBfc3FydChzcSksXG5cdCAgICAgIGN4MSA9IGNvZWYgKiAocnggKiB5MSAvIHJ5KSxcblx0ICAgICAgY3kxID0gY29lZiAqIC0ocnkgKiB4MSAvIHJ4KSxcblx0ICAgICAgc3gyID0gKGxhc3RYICsgeCkgLyAyLFxuXHQgICAgICBzeTIgPSAobGFzdFkgKyB5KSAvIDIsXG5cdCAgICAgIGN4ID0gc3gyICsgKGNvc0FuZ2xlICogY3gxIC0gc2luQW5nbGUgKiBjeTEpLFxuXHQgICAgICBjeSA9IHN5MiArIChzaW5BbmdsZSAqIGN4MSArIGNvc0FuZ2xlICogY3kxKSxcblx0ICAgICAgdXggPSAoeDEgLSBjeDEpIC8gcngsXG5cdCAgICAgIHV5ID0gKHkxIC0gY3kxKSAvIHJ5LFxuXHQgICAgICB2eCA9ICgteDEgLSBjeDEpIC8gcngsXG5cdCAgICAgIHZ5ID0gKC15MSAtIGN5MSkgLyByeSxcblx0ICAgICAgdGVtcCA9IHV4ICogdXggKyB1eSAqIHV5LFxuXHQgICAgICBhbmdsZVN0YXJ0ID0gKHV5IDwgMCA/IC0xIDogMSkgKiBNYXRoLmFjb3ModXggLyBfc3FydCh0ZW1wKSksXG5cdCAgICAgIGFuZ2xlRXh0ZW50ID0gKHV4ICogdnkgLSB1eSAqIHZ4IDwgMCA/IC0xIDogMSkgKiBNYXRoLmFjb3MoKHV4ICogdnggKyB1eSAqIHZ5KSAvIF9zcXJ0KHRlbXAgKiAodnggKiB2eCArIHZ5ICogdnkpKSk7XG5cblx0ICBpc05hTihhbmdsZUV4dGVudCkgJiYgKGFuZ2xlRXh0ZW50ID0gUEkpO1xuXG5cdCAgaWYgKCFzd2VlcEZsYWcgJiYgYW5nbGVFeHRlbnQgPiAwKSB7XG5cdCAgICBhbmdsZUV4dGVudCAtPSBUV09QSTtcblx0ICB9IGVsc2UgaWYgKHN3ZWVwRmxhZyAmJiBhbmdsZUV4dGVudCA8IDApIHtcblx0ICAgIGFuZ2xlRXh0ZW50ICs9IFRXT1BJO1xuXHQgIH1cblxuXHQgIGFuZ2xlU3RhcnQgJT0gVFdPUEk7XG5cdCAgYW5nbGVFeHRlbnQgJT0gVFdPUEk7XG5cblx0ICB2YXIgc2VnbWVudHMgPSBNYXRoLmNlaWwoX2FicyhhbmdsZUV4dGVudCkgLyAoVFdPUEkgLyA0KSksXG5cdCAgICAgIHJhd1BhdGggPSBbXSxcblx0ICAgICAgYW5nbGVJbmNyZW1lbnQgPSBhbmdsZUV4dGVudCAvIHNlZ21lbnRzLFxuXHQgICAgICBjb250cm9sTGVuZ3RoID0gNCAvIDMgKiBfc2luKGFuZ2xlSW5jcmVtZW50IC8gMikgLyAoMSArIF9jb3MoYW5nbGVJbmNyZW1lbnQgLyAyKSksXG5cdCAgICAgIG1hID0gY29zQW5nbGUgKiByeCxcblx0ICAgICAgbWIgPSBzaW5BbmdsZSAqIHJ4LFxuXHQgICAgICBtYyA9IHNpbkFuZ2xlICogLXJ5LFxuXHQgICAgICBtZCA9IGNvc0FuZ2xlICogcnksXG5cdCAgICAgIGk7XG5cblx0ICBmb3IgKGkgPSAwOyBpIDwgc2VnbWVudHM7IGkrKykge1xuXHQgICAgYW5nbGUgPSBhbmdsZVN0YXJ0ICsgaSAqIGFuZ2xlSW5jcmVtZW50O1xuXHQgICAgeDEgPSBfY29zKGFuZ2xlKTtcblx0ICAgIHkxID0gX3NpbihhbmdsZSk7XG5cdCAgICB1eCA9IF9jb3MoYW5nbGUgKz0gYW5nbGVJbmNyZW1lbnQpO1xuXHQgICAgdXkgPSBfc2luKGFuZ2xlKTtcblx0ICAgIHJhd1BhdGgucHVzaCh4MSAtIGNvbnRyb2xMZW5ndGggKiB5MSwgeTEgKyBjb250cm9sTGVuZ3RoICogeDEsIHV4ICsgY29udHJvbExlbmd0aCAqIHV5LCB1eSAtIGNvbnRyb2xMZW5ndGggKiB1eCwgdXgsIHV5KTtcblx0ICB9XG5cblx0ICBmb3IgKGkgPSAwOyBpIDwgcmF3UGF0aC5sZW5ndGg7IGkgKz0gMikge1xuXHQgICAgeDEgPSByYXdQYXRoW2ldO1xuXHQgICAgeTEgPSByYXdQYXRoW2kgKyAxXTtcblx0ICAgIHJhd1BhdGhbaV0gPSB4MSAqIG1hICsgeTEgKiBtYyArIGN4O1xuXHQgICAgcmF3UGF0aFtpICsgMV0gPSB4MSAqIG1iICsgeTEgKiBtZCArIGN5O1xuXHQgIH1cblxuXHQgIHJhd1BhdGhbaSAtIDJdID0geDtcblx0ICByYXdQYXRoW2kgLSAxXSA9IHk7XG5cdCAgcmV0dXJuIHJhd1BhdGg7XG5cdH1cblxuXHRmdW5jdGlvbiBzdHJpbmdUb1Jhd1BhdGgoZCkge1xuXHQgIHZhciBhID0gKGQgKyBcIlwiKS5yZXBsYWNlKF9zY2llbnRpZmljLCBmdW5jdGlvbiAobSkge1xuXHQgICAgdmFyIG4gPSArbTtcblx0ICAgIHJldHVybiBuIDwgMC4wMDAxICYmIG4gPiAtMC4wMDAxID8gMCA6IG47XG5cdCAgfSkubWF0Y2goX3N2Z1BhdGhFeHApIHx8IFtdLFxuXHQgICAgICBwYXRoID0gW10sXG5cdCAgICAgIHJlbGF0aXZlWCA9IDAsXG5cdCAgICAgIHJlbGF0aXZlWSA9IDAsXG5cdCAgICAgIHR3b1RoaXJkcyA9IDIgLyAzLFxuXHQgICAgICBlbGVtZW50cyA9IGEubGVuZ3RoLFxuXHQgICAgICBwb2ludHMgPSAwLFxuXHQgICAgICBlcnJvck1lc3NhZ2UgPSBcIkVSUk9SOiBtYWxmb3JtZWQgcGF0aDogXCIgKyBkLFxuXHQgICAgICBpLFxuXHQgICAgICBqLFxuXHQgICAgICB4LFxuXHQgICAgICB5LFxuXHQgICAgICBjb21tYW5kLFxuXHQgICAgICBpc1JlbGF0aXZlLFxuXHQgICAgICBzZWdtZW50LFxuXHQgICAgICBzdGFydFgsXG5cdCAgICAgIHN0YXJ0WSxcblx0ICAgICAgZGlmWCxcblx0ICAgICAgZGlmWSxcblx0ICAgICAgYmV6aWVycyxcblx0ICAgICAgcHJldkNvbW1hbmQsXG5cdCAgICAgIGZsYWcxLFxuXHQgICAgICBmbGFnMixcblx0ICAgICAgbGluZSA9IGZ1bmN0aW9uIGxpbmUoc3gsIHN5LCBleCwgZXkpIHtcblx0ICAgIGRpZlggPSAoZXggLSBzeCkgLyAzO1xuXHQgICAgZGlmWSA9IChleSAtIHN5KSAvIDM7XG5cdCAgICBzZWdtZW50LnB1c2goc3ggKyBkaWZYLCBzeSArIGRpZlksIGV4IC0gZGlmWCwgZXkgLSBkaWZZLCBleCwgZXkpO1xuXHQgIH07XG5cblx0ICBpZiAoIWQgfHwgIWlzTmFOKGFbMF0pIHx8IGlzTmFOKGFbMV0pKSB7XG5cdCAgICBjb25zb2xlLmxvZyhlcnJvck1lc3NhZ2UpO1xuXHQgICAgcmV0dXJuIHBhdGg7XG5cdCAgfVxuXG5cdCAgZm9yIChpID0gMDsgaSA8IGVsZW1lbnRzOyBpKyspIHtcblx0ICAgIHByZXZDb21tYW5kID0gY29tbWFuZDtcblxuXHQgICAgaWYgKGlzTmFOKGFbaV0pKSB7XG5cdCAgICAgIGNvbW1hbmQgPSBhW2ldLnRvVXBwZXJDYXNlKCk7XG5cdCAgICAgIGlzUmVsYXRpdmUgPSBjb21tYW5kICE9PSBhW2ldO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaS0tO1xuXHQgICAgfVxuXG5cdCAgICB4ID0gK2FbaSArIDFdO1xuXHQgICAgeSA9ICthW2kgKyAyXTtcblxuXHQgICAgaWYgKGlzUmVsYXRpdmUpIHtcblx0ICAgICAgeCArPSByZWxhdGl2ZVg7XG5cdCAgICAgIHkgKz0gcmVsYXRpdmVZO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIWkpIHtcblx0ICAgICAgc3RhcnRYID0geDtcblx0ICAgICAgc3RhcnRZID0geTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGNvbW1hbmQgPT09IFwiTVwiKSB7XG5cdCAgICAgIGlmIChzZWdtZW50KSB7XG5cdCAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoIDwgOCkge1xuXHQgICAgICAgICAgcGF0aC5sZW5ndGggLT0gMTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcG9pbnRzICs9IHNlZ21lbnQubGVuZ3RoO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHJlbGF0aXZlWCA9IHN0YXJ0WCA9IHg7XG5cdCAgICAgIHJlbGF0aXZlWSA9IHN0YXJ0WSA9IHk7XG5cdCAgICAgIHNlZ21lbnQgPSBbeCwgeV07XG5cdCAgICAgIHBhdGgucHVzaChzZWdtZW50KTtcblx0ICAgICAgaSArPSAyO1xuXHQgICAgICBjb21tYW5kID0gXCJMXCI7XG5cdCAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiQ1wiKSB7XG5cdCAgICAgIGlmICghc2VnbWVudCkge1xuXHQgICAgICAgIHNlZ21lbnQgPSBbMCwgMF07XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoIWlzUmVsYXRpdmUpIHtcblx0ICAgICAgICByZWxhdGl2ZVggPSByZWxhdGl2ZVkgPSAwO1xuXHQgICAgICB9XG5cblx0ICAgICAgc2VnbWVudC5wdXNoKHgsIHksIHJlbGF0aXZlWCArIGFbaSArIDNdICogMSwgcmVsYXRpdmVZICsgYVtpICsgNF0gKiAxLCByZWxhdGl2ZVggKz0gYVtpICsgNV0gKiAxLCByZWxhdGl2ZVkgKz0gYVtpICsgNl0gKiAxKTtcblx0ICAgICAgaSArPSA2O1xuXHQgICAgfSBlbHNlIGlmIChjb21tYW5kID09PSBcIlNcIikge1xuXHQgICAgICBkaWZYID0gcmVsYXRpdmVYO1xuXHQgICAgICBkaWZZID0gcmVsYXRpdmVZO1xuXG5cdCAgICAgIGlmIChwcmV2Q29tbWFuZCA9PT0gXCJDXCIgfHwgcHJldkNvbW1hbmQgPT09IFwiU1wiKSB7XG5cdCAgICAgICAgZGlmWCArPSByZWxhdGl2ZVggLSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gNF07XG5cdCAgICAgICAgZGlmWSArPSByZWxhdGl2ZVkgLSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gM107XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoIWlzUmVsYXRpdmUpIHtcblx0ICAgICAgICByZWxhdGl2ZVggPSByZWxhdGl2ZVkgPSAwO1xuXHQgICAgICB9XG5cblx0ICAgICAgc2VnbWVudC5wdXNoKGRpZlgsIGRpZlksIHgsIHksIHJlbGF0aXZlWCArPSBhW2kgKyAzXSAqIDEsIHJlbGF0aXZlWSArPSBhW2kgKyA0XSAqIDEpO1xuXHQgICAgICBpICs9IDQ7XG5cdCAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiUVwiKSB7XG5cdCAgICAgIGRpZlggPSByZWxhdGl2ZVggKyAoeCAtIHJlbGF0aXZlWCkgKiB0d29UaGlyZHM7XG5cdCAgICAgIGRpZlkgPSByZWxhdGl2ZVkgKyAoeSAtIHJlbGF0aXZlWSkgKiB0d29UaGlyZHM7XG5cblx0ICAgICAgaWYgKCFpc1JlbGF0aXZlKSB7XG5cdCAgICAgICAgcmVsYXRpdmVYID0gcmVsYXRpdmVZID0gMDtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJlbGF0aXZlWCArPSBhW2kgKyAzXSAqIDE7XG5cdCAgICAgIHJlbGF0aXZlWSArPSBhW2kgKyA0XSAqIDE7XG5cdCAgICAgIHNlZ21lbnQucHVzaChkaWZYLCBkaWZZLCByZWxhdGl2ZVggKyAoeCAtIHJlbGF0aXZlWCkgKiB0d29UaGlyZHMsIHJlbGF0aXZlWSArICh5IC0gcmVsYXRpdmVZKSAqIHR3b1RoaXJkcywgcmVsYXRpdmVYLCByZWxhdGl2ZVkpO1xuXHQgICAgICBpICs9IDQ7XG5cdCAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiVFwiKSB7XG5cdCAgICAgIGRpZlggPSByZWxhdGl2ZVggLSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gNF07XG5cdCAgICAgIGRpZlkgPSByZWxhdGl2ZVkgLSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gM107XG5cdCAgICAgIHNlZ21lbnQucHVzaChyZWxhdGl2ZVggKyBkaWZYLCByZWxhdGl2ZVkgKyBkaWZZLCB4ICsgKHJlbGF0aXZlWCArIGRpZlggKiAxLjUgLSB4KSAqIHR3b1RoaXJkcywgeSArIChyZWxhdGl2ZVkgKyBkaWZZICogMS41IC0geSkgKiB0d29UaGlyZHMsIHJlbGF0aXZlWCA9IHgsIHJlbGF0aXZlWSA9IHkpO1xuXHQgICAgICBpICs9IDI7XG5cdCAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiSFwiKSB7XG5cdCAgICAgIGxpbmUocmVsYXRpdmVYLCByZWxhdGl2ZVksIHJlbGF0aXZlWCA9IHgsIHJlbGF0aXZlWSk7XG5cdCAgICAgIGkgKz0gMTtcblx0ICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJWXCIpIHtcblx0ICAgICAgbGluZShyZWxhdGl2ZVgsIHJlbGF0aXZlWSwgcmVsYXRpdmVYLCByZWxhdGl2ZVkgPSB4ICsgKGlzUmVsYXRpdmUgPyByZWxhdGl2ZVkgLSByZWxhdGl2ZVggOiAwKSk7XG5cdCAgICAgIGkgKz0gMTtcblx0ICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJMXCIgfHwgY29tbWFuZCA9PT0gXCJaXCIpIHtcblx0ICAgICAgaWYgKGNvbW1hbmQgPT09IFwiWlwiKSB7XG5cdCAgICAgICAgeCA9IHN0YXJ0WDtcblx0ICAgICAgICB5ID0gc3RhcnRZO1xuXHQgICAgICAgIHNlZ21lbnQuY2xvc2VkID0gdHJ1ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChjb21tYW5kID09PSBcIkxcIiB8fCBfYWJzKHJlbGF0aXZlWCAtIHgpID4gMC41IHx8IF9hYnMocmVsYXRpdmVZIC0geSkgPiAwLjUpIHtcblx0ICAgICAgICBsaW5lKHJlbGF0aXZlWCwgcmVsYXRpdmVZLCB4LCB5KTtcblxuXHQgICAgICAgIGlmIChjb21tYW5kID09PSBcIkxcIikge1xuXHQgICAgICAgICAgaSArPSAyO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHJlbGF0aXZlWCA9IHg7XG5cdCAgICAgIHJlbGF0aXZlWSA9IHk7XG5cdCAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiQVwiKSB7XG5cdCAgICAgIGZsYWcxID0gYVtpICsgNF07XG5cdCAgICAgIGZsYWcyID0gYVtpICsgNV07XG5cdCAgICAgIGRpZlggPSBhW2kgKyA2XTtcblx0ICAgICAgZGlmWSA9IGFbaSArIDddO1xuXHQgICAgICBqID0gNztcblxuXHQgICAgICBpZiAoZmxhZzEubGVuZ3RoID4gMSkge1xuXHQgICAgICAgIGlmIChmbGFnMS5sZW5ndGggPCAzKSB7XG5cdCAgICAgICAgICBkaWZZID0gZGlmWDtcblx0ICAgICAgICAgIGRpZlggPSBmbGFnMjtcblx0ICAgICAgICAgIGotLTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgZGlmWSA9IGZsYWcyO1xuXHQgICAgICAgICAgZGlmWCA9IGZsYWcxLnN1YnN0cigyKTtcblx0ICAgICAgICAgIGogLT0gMjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmbGFnMiA9IGZsYWcxLmNoYXJBdCgxKTtcblx0ICAgICAgICBmbGFnMSA9IGZsYWcxLmNoYXJBdCgwKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGJlemllcnMgPSBhcmNUb1NlZ21lbnQocmVsYXRpdmVYLCByZWxhdGl2ZVksICthW2kgKyAxXSwgK2FbaSArIDJdLCArYVtpICsgM10sICtmbGFnMSwgK2ZsYWcyLCAoaXNSZWxhdGl2ZSA/IHJlbGF0aXZlWCA6IDApICsgZGlmWCAqIDEsIChpc1JlbGF0aXZlID8gcmVsYXRpdmVZIDogMCkgKyBkaWZZICogMSk7XG5cdCAgICAgIGkgKz0gajtcblxuXHQgICAgICBpZiAoYmV6aWVycykge1xuXHQgICAgICAgIGZvciAoaiA9IDA7IGogPCBiZXppZXJzLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICBzZWdtZW50LnB1c2goYmV6aWVyc1tqXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmVsYXRpdmVYID0gc2VnbWVudFtzZWdtZW50Lmxlbmd0aCAtIDJdO1xuXHQgICAgICByZWxhdGl2ZVkgPSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gMV07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBjb25zb2xlLmxvZyhlcnJvck1lc3NhZ2UpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGkgPSBzZWdtZW50Lmxlbmd0aDtcblxuXHQgIGlmIChpIDwgNikge1xuXHQgICAgcGF0aC5wb3AoKTtcblx0ICAgIGkgPSAwO1xuXHQgIH0gZWxzZSBpZiAoc2VnbWVudFswXSA9PT0gc2VnbWVudFtpIC0gMl0gJiYgc2VnbWVudFsxXSA9PT0gc2VnbWVudFtpIC0gMV0pIHtcblx0ICAgIHNlZ21lbnQuY2xvc2VkID0gdHJ1ZTtcblx0ICB9XG5cblx0ICBwYXRoLnRvdGFsUG9pbnRzID0gcG9pbnRzICsgaTtcblx0ICByZXR1cm4gcGF0aDtcblx0fVxuXHRmdW5jdGlvbiBmbGF0UG9pbnRzVG9TZWdtZW50KHBvaW50cywgY3VydmluZXNzKSB7XG5cdCAgaWYgKGN1cnZpbmVzcyA9PT0gdm9pZCAwKSB7XG5cdCAgICBjdXJ2aW5lc3MgPSAxO1xuXHQgIH1cblxuXHQgIHZhciB4ID0gcG9pbnRzWzBdLFxuXHQgICAgICB5ID0gMCxcblx0ICAgICAgc2VnbWVudCA9IFt4LCB5XSxcblx0ICAgICAgaSA9IDI7XG5cblx0ICBmb3IgKDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMikge1xuXHQgICAgc2VnbWVudC5wdXNoKHgsIHksIHBvaW50c1tpXSwgeSA9IChwb2ludHNbaV0gLSB4KSAqIGN1cnZpbmVzcyAvIDIsIHggPSBwb2ludHNbaV0sIC15KTtcblx0ICB9XG5cblx0ICByZXR1cm4gc2VnbWVudDtcblx0fVxuXHRmdW5jdGlvbiBwb2ludHNUb1NlZ21lbnQocG9pbnRzLCBjdXJ2aW5lc3MpIHtcblx0ICBfYWJzKHBvaW50c1swXSAtIHBvaW50c1syXSkgPCAxZS00ICYmIF9hYnMocG9pbnRzWzFdIC0gcG9pbnRzWzNdKSA8IDFlLTQgJiYgKHBvaW50cyA9IHBvaW50cy5zbGljZSgyKSk7XG5cdCAgdmFyIGwgPSBwb2ludHMubGVuZ3RoIC0gMixcblx0ICAgICAgeCA9ICtwb2ludHNbMF0sXG5cdCAgICAgIHkgPSArcG9pbnRzWzFdLFxuXHQgICAgICBuZXh0WCA9ICtwb2ludHNbMl0sXG5cdCAgICAgIG5leHRZID0gK3BvaW50c1szXSxcblx0ICAgICAgc2VnbWVudCA9IFt4LCB5LCB4LCB5XSxcblx0ICAgICAgZHgyID0gbmV4dFggLSB4LFxuXHQgICAgICBkeTIgPSBuZXh0WSAtIHksXG5cdCAgICAgIGNsb3NlZCA9IE1hdGguYWJzKHBvaW50c1tsXSAtIHgpIDwgMC4wMDEgJiYgTWF0aC5hYnMocG9pbnRzW2wgKyAxXSAtIHkpIDwgMC4wMDEsXG5cdCAgICAgIHByZXZYLFxuXHQgICAgICBwcmV2WSxcblx0ICAgICAgaSxcblx0ICAgICAgZHgxLFxuXHQgICAgICBkeTEsXG5cdCAgICAgIHIxLFxuXHQgICAgICByMixcblx0ICAgICAgcjMsXG5cdCAgICAgIHRsLFxuXHQgICAgICBteDEsXG5cdCAgICAgIG14Mixcblx0ICAgICAgbXhtLFxuXHQgICAgICBteTEsXG5cdCAgICAgIG15Mixcblx0ICAgICAgbXltO1xuXG5cdCAgaWYgKGNsb3NlZCkge1xuXHQgICAgcG9pbnRzLnB1c2gobmV4dFgsIG5leHRZKTtcblx0ICAgIG5leHRYID0geDtcblx0ICAgIG5leHRZID0geTtcblx0ICAgIHggPSBwb2ludHNbbCAtIDJdO1xuXHQgICAgeSA9IHBvaW50c1tsIC0gMV07XG5cdCAgICBwb2ludHMudW5zaGlmdCh4LCB5KTtcblx0ICAgIGwgKz0gNDtcblx0ICB9XG5cblx0ICBjdXJ2aW5lc3MgPSBjdXJ2aW5lc3MgfHwgY3VydmluZXNzID09PSAwID8gK2N1cnZpbmVzcyA6IDE7XG5cblx0ICBmb3IgKGkgPSAyOyBpIDwgbDsgaSArPSAyKSB7XG5cdCAgICBwcmV2WCA9IHg7XG5cdCAgICBwcmV2WSA9IHk7XG5cdCAgICB4ID0gbmV4dFg7XG5cdCAgICB5ID0gbmV4dFk7XG5cdCAgICBuZXh0WCA9ICtwb2ludHNbaSArIDJdO1xuXHQgICAgbmV4dFkgPSArcG9pbnRzW2kgKyAzXTtcblxuXHQgICAgaWYgKHggPT09IG5leHRYICYmIHkgPT09IG5leHRZKSB7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXG5cdCAgICBkeDEgPSBkeDI7XG5cdCAgICBkeTEgPSBkeTI7XG5cdCAgICBkeDIgPSBuZXh0WCAtIHg7XG5cdCAgICBkeTIgPSBuZXh0WSAtIHk7XG5cdCAgICByMSA9IF9zcXJ0KGR4MSAqIGR4MSArIGR5MSAqIGR5MSk7XG5cdCAgICByMiA9IF9zcXJ0KGR4MiAqIGR4MiArIGR5MiAqIGR5Mik7XG5cdCAgICByMyA9IF9zcXJ0KE1hdGgucG93KGR4MiAvIHIyICsgZHgxIC8gcjEsIDIpICsgTWF0aC5wb3coZHkyIC8gcjIgKyBkeTEgLyByMSwgMikpO1xuXHQgICAgdGwgPSAocjEgKyByMikgKiBjdXJ2aW5lc3MgKiAwLjI1IC8gcjM7XG5cdCAgICBteDEgPSB4IC0gKHggLSBwcmV2WCkgKiAocjEgPyB0bCAvIHIxIDogMCk7XG5cdCAgICBteDIgPSB4ICsgKG5leHRYIC0geCkgKiAocjIgPyB0bCAvIHIyIDogMCk7XG5cdCAgICBteG0gPSB4IC0gKG14MSArICgobXgyIC0gbXgxKSAqIChyMSAqIDMgLyAocjEgKyByMikgKyAwLjUpIC8gNCB8fCAwKSk7XG5cdCAgICBteTEgPSB5IC0gKHkgLSBwcmV2WSkgKiAocjEgPyB0bCAvIHIxIDogMCk7XG5cdCAgICBteTIgPSB5ICsgKG5leHRZIC0geSkgKiAocjIgPyB0bCAvIHIyIDogMCk7XG5cdCAgICBteW0gPSB5IC0gKG15MSArICgobXkyIC0gbXkxKSAqIChyMSAqIDMgLyAocjEgKyByMikgKyAwLjUpIC8gNCB8fCAwKSk7XG5cblx0ICAgIGlmICh4ICE9PSBwcmV2WCB8fCB5ICE9PSBwcmV2WSkge1xuXHQgICAgICBzZWdtZW50LnB1c2goX3JvdW5kKG14MSArIG14bSksIF9yb3VuZChteTEgKyBteW0pLCBfcm91bmQoeCksIF9yb3VuZCh5KSwgX3JvdW5kKG14MiArIG14bSksIF9yb3VuZChteTIgKyBteW0pKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICB4ICE9PSBuZXh0WCB8fCB5ICE9PSBuZXh0WSB8fCBzZWdtZW50Lmxlbmd0aCA8IDQgPyBzZWdtZW50LnB1c2goX3JvdW5kKG5leHRYKSwgX3JvdW5kKG5leHRZKSwgX3JvdW5kKG5leHRYKSwgX3JvdW5kKG5leHRZKSkgOiBzZWdtZW50Lmxlbmd0aCAtPSAyO1xuXG5cdCAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAyKSB7XG5cdCAgICBzZWdtZW50LnB1c2goeCwgeSwgeCwgeSwgeCwgeSk7XG5cdCAgfSBlbHNlIGlmIChjbG9zZWQpIHtcblx0ICAgIHNlZ21lbnQuc3BsaWNlKDAsIDYpO1xuXHQgICAgc2VnbWVudC5sZW5ndGggPSBzZWdtZW50Lmxlbmd0aCAtIDY7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHNlZ21lbnQ7XG5cdH1cblx0ZnVuY3Rpb24gcmF3UGF0aFRvU3RyaW5nKHJhd1BhdGgpIHtcblx0ICBpZiAoX2lzTnVtYmVyKHJhd1BhdGhbMF0pKSB7XG5cdCAgICByYXdQYXRoID0gW3Jhd1BhdGhdO1xuXHQgIH1cblxuXHQgIHZhciByZXN1bHQgPSBcIlwiLFxuXHQgICAgICBsID0gcmF3UGF0aC5sZW5ndGgsXG5cdCAgICAgIHNsLFxuXHQgICAgICBzLFxuXHQgICAgICBpLFxuXHQgICAgICBzZWdtZW50O1xuXG5cdCAgZm9yIChzID0gMDsgcyA8IGw7IHMrKykge1xuXHQgICAgc2VnbWVudCA9IHJhd1BhdGhbc107XG5cdCAgICByZXN1bHQgKz0gXCJNXCIgKyBfcm91bmQoc2VnbWVudFswXSkgKyBcIixcIiArIF9yb3VuZChzZWdtZW50WzFdKSArIFwiIENcIjtcblx0ICAgIHNsID0gc2VnbWVudC5sZW5ndGg7XG5cblx0ICAgIGZvciAoaSA9IDI7IGkgPCBzbDsgaSsrKSB7XG5cdCAgICAgIHJlc3VsdCArPSBfcm91bmQoc2VnbWVudFtpKytdKSArIFwiLFwiICsgX3JvdW5kKHNlZ21lbnRbaSsrXSkgKyBcIiBcIiArIF9yb3VuZChzZWdtZW50W2krK10pICsgXCIsXCIgKyBfcm91bmQoc2VnbWVudFtpKytdKSArIFwiIFwiICsgX3JvdW5kKHNlZ21lbnRbaSsrXSkgKyBcIixcIiArIF9yb3VuZChzZWdtZW50W2ldKSArIFwiIFwiO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoc2VnbWVudC5jbG9zZWQpIHtcblx0ICAgICAgcmVzdWx0ICs9IFwielwiO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHR2YXIgX2RvYyxcblx0ICAgIF93aW4sXG5cdCAgICBfZG9jRWxlbWVudCxcblx0ICAgIF9ib2R5LFxuXHQgICAgX2RpdkNvbnRhaW5lcixcblx0ICAgIF9zdmdDb250YWluZXIsXG5cdCAgICBfaWRlbnRpdHlNYXRyaXgsXG5cdCAgICBfZ0VsLFxuXHQgICAgX3RyYW5zZm9ybVByb3AgPSBcInRyYW5zZm9ybVwiLFxuXHQgICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBfdHJhbnNmb3JtUHJvcCArIFwiT3JpZ2luXCIsXG5cdCAgICBfaGFzT2Zmc2V0QnVnLFxuXHQgICAgX3NldERvYyA9IGZ1bmN0aW9uIF9zZXREb2MoZWxlbWVudCkge1xuXHQgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgZWxlbWVudDtcblxuXHQgIGlmICghKF90cmFuc2Zvcm1Qcm9wIGluIGVsZW1lbnQuc3R5bGUpICYmIFwibXNUcmFuc2Zvcm1cIiBpbiBlbGVtZW50LnN0eWxlKSB7XG5cdCAgICBfdHJhbnNmb3JtUHJvcCA9IFwibXNUcmFuc2Zvcm1cIjtcblx0ICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX3RyYW5zZm9ybVByb3AgKyBcIk9yaWdpblwiO1xuXHQgIH1cblxuXHQgIHdoaWxlIChkb2MucGFyZW50Tm9kZSAmJiAoZG9jID0gZG9jLnBhcmVudE5vZGUpKSB7fVxuXG5cdCAgX3dpbiA9IHdpbmRvdztcblx0ICBfaWRlbnRpdHlNYXRyaXggPSBuZXcgTWF0cml4MkQoKTtcblxuXHQgIGlmIChkb2MpIHtcblx0ICAgIF9kb2MgPSBkb2M7XG5cdCAgICBfZG9jRWxlbWVudCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdCAgICBfYm9keSA9IGRvYy5ib2R5O1xuXHQgICAgX2dFbCA9IF9kb2MuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuXHQgICAgX2dFbC5zdHlsZS50cmFuc2Zvcm0gPSBcIm5vbmVcIjtcblx0ICAgIHZhciBkMSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuXHQgICAgICAgIGQyID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG5cdCAgICAgICAgcm9vdCA9IGRvYyAmJiAoZG9jLmJvZHkgfHwgZG9jLmZpcnN0RWxlbWVudENoaWxkKTtcblxuXHQgICAgaWYgKHJvb3QgJiYgcm9vdC5hcHBlbmRDaGlsZCkge1xuXHQgICAgICByb290LmFwcGVuZENoaWxkKGQxKTtcblx0ICAgICAgZDEuYXBwZW5kQ2hpbGQoZDIpO1xuXHQgICAgICBkMS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcInBvc2l0aW9uOnN0YXRpYzt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwwLDFweClcIik7XG5cdCAgICAgIF9oYXNPZmZzZXRCdWcgPSBkMi5vZmZzZXRQYXJlbnQgIT09IGQxO1xuXHQgICAgICByb290LnJlbW92ZUNoaWxkKGQxKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gZG9jO1xuXHR9LFxuXHQgICAgX2ZvcmNlTm9uWmVyb1NjYWxlID0gZnVuY3Rpb24gX2ZvcmNlTm9uWmVyb1NjYWxlKGUpIHtcblx0ICB2YXIgYSwgY2FjaGU7XG5cblx0ICB3aGlsZSAoZSAmJiBlICE9PSBfYm9keSkge1xuXHQgICAgY2FjaGUgPSBlLl9nc2FwO1xuXHQgICAgY2FjaGUgJiYgY2FjaGUudW5jYWNoZSAmJiBjYWNoZS5nZXQoZSwgXCJ4XCIpO1xuXG5cdCAgICBpZiAoY2FjaGUgJiYgIWNhY2hlLnNjYWxlWCAmJiAhY2FjaGUuc2NhbGVZICYmIGNhY2hlLnJlbmRlclRyYW5zZm9ybSkge1xuXHQgICAgICBjYWNoZS5zY2FsZVggPSBjYWNoZS5zY2FsZVkgPSAxZS00O1xuXHQgICAgICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0oMSwgY2FjaGUpO1xuXHQgICAgICBhID8gYS5wdXNoKGNhY2hlKSA6IGEgPSBbY2FjaGVdO1xuXHQgICAgfVxuXG5cdCAgICBlID0gZS5wYXJlbnROb2RlO1xuXHQgIH1cblxuXHQgIHJldHVybiBhO1xuXHR9LFxuXHQgICAgX3N2Z1RlbXBzID0gW10sXG5cdCAgICBfZGl2VGVtcHMgPSBbXSxcblx0ICAgIF9nZXREb2NTY3JvbGxUb3AgPSBmdW5jdGlvbiBfZ2V0RG9jU2Nyb2xsVG9wKCkge1xuXHQgIHJldHVybiBfd2luLnBhZ2VZT2Zmc2V0IHx8IF9kb2Muc2Nyb2xsVG9wIHx8IF9kb2NFbGVtZW50LnNjcm9sbFRvcCB8fCBfYm9keS5zY3JvbGxUb3AgfHwgMDtcblx0fSxcblx0ICAgIF9nZXREb2NTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gX2dldERvY1Njcm9sbExlZnQoKSB7XG5cdCAgcmV0dXJuIF93aW4ucGFnZVhPZmZzZXQgfHwgX2RvYy5zY3JvbGxMZWZ0IHx8IF9kb2NFbGVtZW50LnNjcm9sbExlZnQgfHwgX2JvZHkuc2Nyb2xsTGVmdCB8fCAwO1xuXHR9LFxuXHQgICAgX3N2Z093bmVyID0gZnVuY3Rpb24gX3N2Z093bmVyKGVsZW1lbnQpIHtcblx0ICByZXR1cm4gZWxlbWVudC5vd25lclNWR0VsZW1lbnQgfHwgKChlbGVtZW50LnRhZ05hbWUgKyBcIlwiKS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiID8gZWxlbWVudCA6IG51bGwpO1xuXHR9LFxuXHQgICAgX2lzRml4ZWQgPSBmdW5jdGlvbiBfaXNGaXhlZChlbGVtZW50KSB7XG5cdCAgaWYgKF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiKSB7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cblx0ICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXG5cdCAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xuXHQgICAgcmV0dXJuIF9pc0ZpeGVkKGVsZW1lbnQpO1xuXHQgIH1cblx0fSxcblx0ICAgIF9jcmVhdGVTaWJsaW5nID0gZnVuY3Rpb24gX2NyZWF0ZVNpYmxpbmcoZWxlbWVudCwgaSkge1xuXHQgIGlmIChlbGVtZW50LnBhcmVudE5vZGUgJiYgKF9kb2MgfHwgX3NldERvYyhlbGVtZW50KSkpIHtcblx0ICAgIHZhciBzdmcgPSBfc3ZnT3duZXIoZWxlbWVudCksXG5cdCAgICAgICAgbnMgPSBzdmcgPyBzdmcuZ2V0QXR0cmlidXRlKFwieG1sbnNcIikgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIDogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsXG5cdCAgICAgICAgdHlwZSA9IHN2ZyA/IGkgPyBcInJlY3RcIiA6IFwiZ1wiIDogXCJkaXZcIixcblx0ICAgICAgICB4ID0gaSAhPT0gMiA/IDAgOiAxMDAsXG5cdCAgICAgICAgeSA9IGkgPT09IDMgPyAxMDAgOiAwLFxuXHQgICAgICAgIGNzcyA9IFwicG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jaztwb2ludGVyLWV2ZW50czpub25lO21hcmdpbjowO3BhZGRpbmc6MDtcIixcblx0ICAgICAgICBlID0gX2RvYy5jcmVhdGVFbGVtZW50TlMgPyBfZG9jLmNyZWF0ZUVsZW1lbnROUyhucy5yZXBsYWNlKC9eaHR0cHMvLCBcImh0dHBcIiksIHR5cGUpIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpO1xuXG5cdCAgICBpZiAoaSkge1xuXHQgICAgICBpZiAoIXN2Zykge1xuXHQgICAgICAgIGlmICghX2RpdkNvbnRhaW5lcikge1xuXHQgICAgICAgICAgX2RpdkNvbnRhaW5lciA9IF9jcmVhdGVTaWJsaW5nKGVsZW1lbnQpO1xuXHQgICAgICAgICAgX2RpdkNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gY3NzO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGUuc3R5bGUuY3NzVGV4dCA9IGNzcyArIFwid2lkdGg6MC4xcHg7aGVpZ2h0OjAuMXB4O3RvcDpcIiArIHkgKyBcInB4O2xlZnQ6XCIgKyB4ICsgXCJweFwiO1xuXG5cdCAgICAgICAgX2RpdkNvbnRhaW5lci5hcHBlbmRDaGlsZChlKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBfc3ZnQ29udGFpbmVyIHx8IChfc3ZnQ29udGFpbmVyID0gX2NyZWF0ZVNpYmxpbmcoZWxlbWVudCkpO1xuXHQgICAgICAgIGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgMC4wMSk7XG5cdCAgICAgICAgZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgMC4wMSk7XG5cdCAgICAgICAgZS5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpXCIpO1xuXG5cdCAgICAgICAgX3N2Z0NvbnRhaW5lci5hcHBlbmRDaGlsZChlKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gZTtcblx0ICB9XG5cblx0ICB0aHJvdyBcIk5lZWQgZG9jdW1lbnQgYW5kIHBhcmVudC5cIjtcblx0fSxcblx0ICAgIF9jb25zb2xpZGF0ZSA9IGZ1bmN0aW9uIF9jb25zb2xpZGF0ZShtKSB7XG5cdCAgdmFyIGMgPSBuZXcgTWF0cml4MkQoKSxcblx0ICAgICAgaSA9IDA7XG5cblx0ICBmb3IgKDsgaSA8IG0ubnVtYmVyT2ZJdGVtczsgaSsrKSB7XG5cdCAgICBjLm11bHRpcGx5KG0uZ2V0SXRlbShpKS5tYXRyaXgpO1xuXHQgIH1cblxuXHQgIHJldHVybiBjO1xuXHR9LFxuXHQgICAgX2dldENUTSA9IGZ1bmN0aW9uIF9nZXRDVE0oc3ZnKSB7XG5cdCAgdmFyIG0gPSBzdmcuZ2V0Q1RNKCksXG5cdCAgICAgIHRyYW5zZm9ybTtcblxuXHQgIGlmICghbSkge1xuXHQgICAgdHJhbnNmb3JtID0gc3ZnLnN0eWxlW190cmFuc2Zvcm1Qcm9wXTtcblx0ICAgIHN2Zy5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSBcIm5vbmVcIjtcblx0ICAgIHN2Zy5hcHBlbmRDaGlsZChfZ0VsKTtcblx0ICAgIG0gPSBfZ0VsLmdldENUTSgpO1xuXHQgICAgc3ZnLnJlbW92ZUNoaWxkKF9nRWwpO1xuXHQgICAgdHJhbnNmb3JtID8gc3ZnLnN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybSA6IHN2Zy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShfdHJhbnNmb3JtUHJvcC5yZXBsYWNlKC8oW0EtWl0pL2csIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuXHQgIH1cblxuXHQgIHJldHVybiBtIHx8IF9pZGVudGl0eU1hdHJpeC5jbG9uZSgpO1xuXHR9LFxuXHQgICAgX3BsYWNlU2libGluZ3MgPSBmdW5jdGlvbiBfcGxhY2VTaWJsaW5ncyhlbGVtZW50LCBhZGp1c3RHT2Zmc2V0KSB7XG5cdCAgdmFyIHN2ZyA9IF9zdmdPd25lcihlbGVtZW50KSxcblx0ICAgICAgaXNSb290U1ZHID0gZWxlbWVudCA9PT0gc3ZnLFxuXHQgICAgICBzaWJsaW5ncyA9IHN2ZyA/IF9zdmdUZW1wcyA6IF9kaXZUZW1wcyxcblx0ICAgICAgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlLFxuXHQgICAgICBjb250YWluZXIsXG5cdCAgICAgIG0sXG5cdCAgICAgIGIsXG5cdCAgICAgIHgsXG5cdCAgICAgIHksXG5cdCAgICAgIGNzO1xuXG5cdCAgaWYgKGVsZW1lbnQgPT09IF93aW4pIHtcblx0ICAgIHJldHVybiBlbGVtZW50O1xuXHQgIH1cblxuXHQgIHNpYmxpbmdzLmxlbmd0aCB8fCBzaWJsaW5ncy5wdXNoKF9jcmVhdGVTaWJsaW5nKGVsZW1lbnQsIDEpLCBfY3JlYXRlU2libGluZyhlbGVtZW50LCAyKSwgX2NyZWF0ZVNpYmxpbmcoZWxlbWVudCwgMykpO1xuXHQgIGNvbnRhaW5lciA9IHN2ZyA/IF9zdmdDb250YWluZXIgOiBfZGl2Q29udGFpbmVyO1xuXG5cdCAgaWYgKHN2Zykge1xuXHQgICAgaWYgKGlzUm9vdFNWRykge1xuXHQgICAgICBiID0gX2dldENUTShlbGVtZW50KTtcblx0ICAgICAgeCA9IC1iLmUgLyBiLmE7XG5cdCAgICAgIHkgPSAtYi5mIC8gYi5kO1xuXHQgICAgICBtID0gX2lkZW50aXR5TWF0cml4O1xuXHQgICAgfSBlbHNlIGlmIChlbGVtZW50LmdldEJCb3gpIHtcblx0ICAgICAgYiA9IGVsZW1lbnQuZ2V0QkJveCgpO1xuXHQgICAgICBtID0gZWxlbWVudC50cmFuc2Zvcm0gPyBlbGVtZW50LnRyYW5zZm9ybS5iYXNlVmFsIDoge307XG5cdCAgICAgIG0gPSAhbS5udW1iZXJPZkl0ZW1zID8gX2lkZW50aXR5TWF0cml4IDogbS5udW1iZXJPZkl0ZW1zID4gMSA/IF9jb25zb2xpZGF0ZShtKSA6IG0uZ2V0SXRlbSgwKS5tYXRyaXg7XG5cdCAgICAgIHggPSBtLmEgKiBiLnggKyBtLmMgKiBiLnk7XG5cdCAgICAgIHkgPSBtLmIgKiBiLnggKyBtLmQgKiBiLnk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBtID0gbmV3IE1hdHJpeDJEKCk7XG5cdCAgICAgIHggPSB5ID0gMDtcblx0ICAgIH1cblxuXHQgICAgaWYgKGFkanVzdEdPZmZzZXQgJiYgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZ1wiKSB7XG5cdCAgICAgIHggPSB5ID0gMDtcblx0ICAgIH1cblxuXHQgICAgKGlzUm9vdFNWRyA/IHN2ZyA6IHBhcmVudCkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblx0ICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJtYXRyaXgoXCIgKyBtLmEgKyBcIixcIiArIG0uYiArIFwiLFwiICsgbS5jICsgXCIsXCIgKyBtLmQgKyBcIixcIiArIChtLmUgKyB4KSArIFwiLFwiICsgKG0uZiArIHkpICsgXCIpXCIpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB4ID0geSA9IDA7XG5cblx0ICAgIGlmIChfaGFzT2Zmc2V0QnVnKSB7XG5cdCAgICAgIG0gPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcblx0ICAgICAgYiA9IGVsZW1lbnQ7XG5cblx0ICAgICAgd2hpbGUgKGIgJiYgKGIgPSBiLnBhcmVudE5vZGUpICYmIGIgIT09IG0gJiYgYi5wYXJlbnROb2RlKSB7XG5cdCAgICAgICAgaWYgKChfd2luLmdldENvbXB1dGVkU3R5bGUoYilbX3RyYW5zZm9ybVByb3BdICsgXCJcIikubGVuZ3RoID4gNCkge1xuXHQgICAgICAgICAgeCA9IGIub2Zmc2V0TGVmdDtcblx0ICAgICAgICAgIHkgPSBiLm9mZnNldFRvcDtcblx0ICAgICAgICAgIGIgPSAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBjcyA9IF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuXHQgICAgaWYgKGNzLnBvc2l0aW9uICE9PSBcImFic29sdXRlXCIgJiYgY3MucG9zaXRpb24gIT09IFwiZml4ZWRcIikge1xuXHQgICAgICBtID0gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG5cblx0ICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQgIT09IG0pIHtcblx0ICAgICAgICB4ICs9IHBhcmVudC5zY3JvbGxMZWZ0IHx8IDA7XG5cdCAgICAgICAgeSArPSBwYXJlbnQuc2Nyb2xsVG9wIHx8IDA7XG5cdCAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgYiA9IGNvbnRhaW5lci5zdHlsZTtcblx0ICAgIGIudG9wID0gZWxlbWVudC5vZmZzZXRUb3AgLSB5ICsgXCJweFwiO1xuXHQgICAgYi5sZWZ0ID0gZWxlbWVudC5vZmZzZXRMZWZ0IC0geCArIFwicHhcIjtcblx0ICAgIGJbX3RyYW5zZm9ybVByb3BdID0gY3NbX3RyYW5zZm9ybVByb3BdO1xuXHQgICAgYltfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBjc1tfdHJhbnNmb3JtT3JpZ2luUHJvcF07XG5cdCAgICBiLnBvc2l0aW9uID0gY3MucG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IFwiZml4ZWRcIiA6IFwiYWJzb2x1dGVcIjtcblx0ICAgIGVsZW1lbnQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXHQgIH1cblxuXHQgIHJldHVybiBjb250YWluZXI7XG5cdH0sXG5cdCAgICBfc2V0TWF0cml4ID0gZnVuY3Rpb24gX3NldE1hdHJpeChtLCBhLCBiLCBjLCBkLCBlLCBmKSB7XG5cdCAgbS5hID0gYTtcblx0ICBtLmIgPSBiO1xuXHQgIG0uYyA9IGM7XG5cdCAgbS5kID0gZDtcblx0ICBtLmUgPSBlO1xuXHQgIG0uZiA9IGY7XG5cdCAgcmV0dXJuIG07XG5cdH07XG5cblx0dmFyIE1hdHJpeDJEID0gZnVuY3Rpb24gKCkge1xuXHQgIGZ1bmN0aW9uIE1hdHJpeDJEKGEsIGIsIGMsIGQsIGUsIGYpIHtcblx0ICAgIGlmIChhID09PSB2b2lkIDApIHtcblx0ICAgICAgYSA9IDE7XG5cdCAgICB9XG5cblx0ICAgIGlmIChiID09PSB2b2lkIDApIHtcblx0ICAgICAgYiA9IDA7XG5cdCAgICB9XG5cblx0ICAgIGlmIChjID09PSB2b2lkIDApIHtcblx0ICAgICAgYyA9IDA7XG5cdCAgICB9XG5cblx0ICAgIGlmIChkID09PSB2b2lkIDApIHtcblx0ICAgICAgZCA9IDE7XG5cdCAgICB9XG5cblx0ICAgIGlmIChlID09PSB2b2lkIDApIHtcblx0ICAgICAgZSA9IDA7XG5cdCAgICB9XG5cblx0ICAgIGlmIChmID09PSB2b2lkIDApIHtcblx0ICAgICAgZiA9IDA7XG5cdCAgICB9XG5cblx0ICAgIF9zZXRNYXRyaXgodGhpcywgYSwgYiwgYywgZCwgZSwgZik7XG5cdCAgfVxuXG5cdCAgdmFyIF9wcm90byA9IE1hdHJpeDJELnByb3RvdHlwZTtcblxuXHQgIF9wcm90by5pbnZlcnNlID0gZnVuY3Rpb24gaW52ZXJzZSgpIHtcblx0ICAgIHZhciBhID0gdGhpcy5hLFxuXHQgICAgICAgIGIgPSB0aGlzLmIsXG5cdCAgICAgICAgYyA9IHRoaXMuYyxcblx0ICAgICAgICBkID0gdGhpcy5kLFxuXHQgICAgICAgIGUgPSB0aGlzLmUsXG5cdCAgICAgICAgZiA9IHRoaXMuZixcblx0ICAgICAgICBkZXRlcm1pbmFudCA9IGEgKiBkIC0gYiAqIGMgfHwgMWUtMTA7XG5cdCAgICByZXR1cm4gX3NldE1hdHJpeCh0aGlzLCBkIC8gZGV0ZXJtaW5hbnQsIC1iIC8gZGV0ZXJtaW5hbnQsIC1jIC8gZGV0ZXJtaW5hbnQsIGEgLyBkZXRlcm1pbmFudCwgKGMgKiBmIC0gZCAqIGUpIC8gZGV0ZXJtaW5hbnQsIC0oYSAqIGYgLSBiICogZSkgLyBkZXRlcm1pbmFudCk7XG5cdCAgfTtcblxuXHQgIF9wcm90by5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG1hdHJpeCkge1xuXHQgICAgdmFyIGEgPSB0aGlzLmEsXG5cdCAgICAgICAgYiA9IHRoaXMuYixcblx0ICAgICAgICBjID0gdGhpcy5jLFxuXHQgICAgICAgIGQgPSB0aGlzLmQsXG5cdCAgICAgICAgZSA9IHRoaXMuZSxcblx0ICAgICAgICBmID0gdGhpcy5mLFxuXHQgICAgICAgIGEyID0gbWF0cml4LmEsXG5cdCAgICAgICAgYjIgPSBtYXRyaXguYyxcblx0ICAgICAgICBjMiA9IG1hdHJpeC5iLFxuXHQgICAgICAgIGQyID0gbWF0cml4LmQsXG5cdCAgICAgICAgZTIgPSBtYXRyaXguZSxcblx0ICAgICAgICBmMiA9IG1hdHJpeC5mO1xuXHQgICAgcmV0dXJuIF9zZXRNYXRyaXgodGhpcywgYTIgKiBhICsgYzIgKiBjLCBhMiAqIGIgKyBjMiAqIGQsIGIyICogYSArIGQyICogYywgYjIgKiBiICsgZDIgKiBkLCBlICsgZTIgKiBhICsgZjIgKiBjLCBmICsgZTIgKiBiICsgZjIgKiBkKTtcblx0ICB9O1xuXG5cdCAgX3Byb3RvLmNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG5cdCAgICByZXR1cm4gbmV3IE1hdHJpeDJEKHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRoaXMuZCwgdGhpcy5lLCB0aGlzLmYpO1xuXHQgIH07XG5cblx0ICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG1hdHJpeCkge1xuXHQgICAgdmFyIGEgPSB0aGlzLmEsXG5cdCAgICAgICAgYiA9IHRoaXMuYixcblx0ICAgICAgICBjID0gdGhpcy5jLFxuXHQgICAgICAgIGQgPSB0aGlzLmQsXG5cdCAgICAgICAgZSA9IHRoaXMuZSxcblx0ICAgICAgICBmID0gdGhpcy5mO1xuXHQgICAgcmV0dXJuIGEgPT09IG1hdHJpeC5hICYmIGIgPT09IG1hdHJpeC5iICYmIGMgPT09IG1hdHJpeC5jICYmIGQgPT09IG1hdHJpeC5kICYmIGUgPT09IG1hdHJpeC5lICYmIGYgPT09IG1hdHJpeC5mO1xuXHQgIH07XG5cblx0ICBfcHJvdG8uYXBwbHkgPSBmdW5jdGlvbiBhcHBseShwb2ludCwgZGVjb3JhdGVlKSB7XG5cdCAgICBpZiAoZGVjb3JhdGVlID09PSB2b2lkIDApIHtcblx0ICAgICAgZGVjb3JhdGVlID0ge307XG5cdCAgICB9XG5cblx0ICAgIHZhciB4ID0gcG9pbnQueCxcblx0ICAgICAgICB5ID0gcG9pbnQueSxcblx0ICAgICAgICBhID0gdGhpcy5hLFxuXHQgICAgICAgIGIgPSB0aGlzLmIsXG5cdCAgICAgICAgYyA9IHRoaXMuYyxcblx0ICAgICAgICBkID0gdGhpcy5kLFxuXHQgICAgICAgIGUgPSB0aGlzLmUsXG5cdCAgICAgICAgZiA9IHRoaXMuZjtcblx0ICAgIGRlY29yYXRlZS54ID0geCAqIGEgKyB5ICogYyArIGUgfHwgMDtcblx0ICAgIGRlY29yYXRlZS55ID0geCAqIGIgKyB5ICogZCArIGYgfHwgMDtcblx0ICAgIHJldHVybiBkZWNvcmF0ZWU7XG5cdCAgfTtcblxuXHQgIHJldHVybiBNYXRyaXgyRDtcblx0fSgpO1xuXHRmdW5jdGlvbiBnZXRHbG9iYWxNYXRyaXgoZWxlbWVudCwgaW52ZXJzZSwgYWRqdXN0R09mZnNldCwgaW5jbHVkZVNjcm9sbEluRml4ZWQpIHtcblx0ICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQucGFyZW50Tm9kZSB8fCAoX2RvYyB8fCBfc2V0RG9jKGVsZW1lbnQpKS5kb2N1bWVudEVsZW1lbnQgPT09IGVsZW1lbnQpIHtcblx0ICAgIHJldHVybiBuZXcgTWF0cml4MkQoKTtcblx0ICB9XG5cblx0ICB2YXIgemVyb1NjYWxlcyA9IF9mb3JjZU5vblplcm9TY2FsZShlbGVtZW50KSxcblx0ICAgICAgc3ZnID0gX3N2Z093bmVyKGVsZW1lbnQpLFxuXHQgICAgICB0ZW1wcyA9IHN2ZyA/IF9zdmdUZW1wcyA6IF9kaXZUZW1wcyxcblx0ICAgICAgY29udGFpbmVyID0gX3BsYWNlU2libGluZ3MoZWxlbWVudCwgYWRqdXN0R09mZnNldCksXG5cdCAgICAgIGIxID0gdGVtcHNbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG5cdCAgICAgIGIyID0gdGVtcHNbMV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG5cdCAgICAgIGIzID0gdGVtcHNbMl0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG5cdCAgICAgIHBhcmVudCA9IGNvbnRhaW5lci5wYXJlbnROb2RlLFxuXHQgICAgICBpc0ZpeGVkID0gIWluY2x1ZGVTY3JvbGxJbkZpeGVkICYmIF9pc0ZpeGVkKGVsZW1lbnQpLFxuXHQgICAgICBtID0gbmV3IE1hdHJpeDJEKChiMi5sZWZ0IC0gYjEubGVmdCkgLyAxMDAsIChiMi50b3AgLSBiMS50b3ApIC8gMTAwLCAoYjMubGVmdCAtIGIxLmxlZnQpIC8gMTAwLCAoYjMudG9wIC0gYjEudG9wKSAvIDEwMCwgYjEubGVmdCArIChpc0ZpeGVkID8gMCA6IF9nZXREb2NTY3JvbGxMZWZ0KCkpLCBiMS50b3AgKyAoaXNGaXhlZCA/IDAgOiBfZ2V0RG9jU2Nyb2xsVG9wKCkpKTtcblxuXHQgIHBhcmVudC5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuXG5cdCAgaWYgKHplcm9TY2FsZXMpIHtcblx0ICAgIGIxID0gemVyb1NjYWxlcy5sZW5ndGg7XG5cblx0ICAgIHdoaWxlIChiMS0tKSB7XG5cdCAgICAgIGIyID0gemVyb1NjYWxlc1tiMV07XG5cdCAgICAgIGIyLnNjYWxlWCA9IGIyLnNjYWxlWSA9IDA7XG5cdCAgICAgIGIyLnJlbmRlclRyYW5zZm9ybSgxLCBiMik7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGludmVyc2UgPyBtLmludmVyc2UoKSA6IG07XG5cdH1cblxuXHQvKiFcblx0ICogTW90aW9uUGF0aFBsdWdpbiAzLjEyLjVcblx0ICogaHR0cHM6Ly9nc2FwLmNvbVxuXHQgKlxuXHQgKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDI0LCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdCAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3NhcC5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3Jcblx0ICogQ2x1YiBHU0FQIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuXHQgKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cblx0Ki9cblxuXHR2YXIgX3hQcm9wcyA9IFwieCx0cmFuc2xhdGVYLGxlZnQsbWFyZ2luTGVmdCx4UGVyY2VudFwiLnNwbGl0KFwiLFwiKSxcblx0ICAgIF95UHJvcHMgPSBcInksdHJhbnNsYXRlWSx0b3AsbWFyZ2luVG9wLHlQZXJjZW50XCIuc3BsaXQoXCIsXCIpLFxuXHQgICAgX0RFRzJSQUQkMSA9IE1hdGguUEkgLyAxODAsXG5cdCAgICBnc2FwLFxuXHQgICAgUHJvcFR3ZWVuLFxuXHQgICAgX2dldFVuaXQsXG5cdCAgICBfdG9BcnJheSxcblx0ICAgIF9nZXRTdHlsZVNhdmVyLFxuXHQgICAgX3JldmVydGluZyxcblx0ICAgIF9nZXRHU0FQID0gZnVuY3Rpb24gX2dldEdTQVAoKSB7XG5cdCAgcmV0dXJuIGdzYXAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG5cdH0sXG5cdCAgICBfcG9wdWxhdGVTZWdtZW50RnJvbUFycmF5ID0gZnVuY3Rpb24gX3BvcHVsYXRlU2VnbWVudEZyb21BcnJheShzZWdtZW50LCB2YWx1ZXMsIHByb3BlcnR5LCBtb2RlKSB7XG5cdCAgdmFyIGwgPSB2YWx1ZXMubGVuZ3RoLFxuXHQgICAgICBzaSA9IG1vZGUgPT09IDIgPyAwIDogbW9kZSxcblx0ICAgICAgaSA9IDAsXG5cdCAgICAgIHY7XG5cblx0ICBmb3IgKDsgaSA8IGw7IGkrKykge1xuXHQgICAgc2VnbWVudFtzaV0gPSB2ID0gcGFyc2VGbG9hdCh2YWx1ZXNbaV1bcHJvcGVydHldKTtcblx0ICAgIG1vZGUgPT09IDIgJiYgKHNlZ21lbnRbc2kgKyAxXSA9IDApO1xuXHQgICAgc2kgKz0gMjtcblx0ICB9XG5cblx0ICByZXR1cm4gc2VnbWVudDtcblx0fSxcblx0ICAgIF9nZXRQcm9wTnVtID0gZnVuY3Rpb24gX2dldFByb3BOdW0odGFyZ2V0LCBwcm9wLCB1bml0KSB7XG5cdCAgcmV0dXJuIHBhcnNlRmxvYXQodGFyZ2V0Ll9nc2FwLmdldCh0YXJnZXQsIHByb3AsIHVuaXQgfHwgXCJweFwiKSkgfHwgMDtcblx0fSxcblx0ICAgIF9yZWxhdGl2aXplID0gZnVuY3Rpb24gX3JlbGF0aXZpemUoc2VnbWVudCkge1xuXHQgIHZhciB4ID0gc2VnbWVudFswXSxcblx0ICAgICAgeSA9IHNlZ21lbnRbMV0sXG5cdCAgICAgIGk7XG5cblx0ICBmb3IgKGkgPSAyOyBpIDwgc2VnbWVudC5sZW5ndGg7IGkgKz0gMikge1xuXHQgICAgeCA9IHNlZ21lbnRbaV0gKz0geDtcblx0ICAgIHkgPSBzZWdtZW50W2kgKyAxXSArPSB5O1xuXHQgIH1cblx0fSxcblx0ICAgIF9zZWdtZW50VG9SYXdQYXRoID0gZnVuY3Rpb24gX3NlZ21lbnRUb1Jhd1BhdGgocGx1Z2luLCBzZWdtZW50LCB0YXJnZXQsIHgsIHksIHNsaWNlciwgdmFycywgdW5pdFgsIHVuaXRZKSB7XG5cdCAgaWYgKHZhcnMudHlwZSA9PT0gXCJjdWJpY1wiKSB7XG5cdCAgICBzZWdtZW50ID0gW3NlZ21lbnRdO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXJzLmZyb21DdXJyZW50ICE9PSBmYWxzZSAmJiBzZWdtZW50LnVuc2hpZnQoX2dldFByb3BOdW0odGFyZ2V0LCB4LCB1bml0WCksIHkgPyBfZ2V0UHJvcE51bSh0YXJnZXQsIHksIHVuaXRZKSA6IDApO1xuXHQgICAgdmFycy5yZWxhdGl2ZSAmJiBfcmVsYXRpdml6ZShzZWdtZW50KTtcblx0ICAgIHZhciBwb2ludEZ1bmMgPSB5ID8gcG9pbnRzVG9TZWdtZW50IDogZmxhdFBvaW50c1RvU2VnbWVudDtcblx0ICAgIHNlZ21lbnQgPSBbcG9pbnRGdW5jKHNlZ21lbnQsIHZhcnMuY3VydmluZXNzKV07XG5cdCAgfVxuXG5cdCAgc2VnbWVudCA9IHNsaWNlcihfYWxpZ24oc2VnbWVudCwgdGFyZ2V0LCB2YXJzKSk7XG5cblx0ICBfYWRkRGltZW5zaW9uYWxQcm9wVHdlZW4ocGx1Z2luLCB0YXJnZXQsIHgsIHNlZ21lbnQsIFwieFwiLCB1bml0WCk7XG5cblx0ICB5ICYmIF9hZGREaW1lbnNpb25hbFByb3BUd2VlbihwbHVnaW4sIHRhcmdldCwgeSwgc2VnbWVudCwgXCJ5XCIsIHVuaXRZKTtcblx0ICByZXR1cm4gY2FjaGVSYXdQYXRoTWVhc3VyZW1lbnRzKHNlZ21lbnQsIHZhcnMucmVzb2x1dGlvbiB8fCAodmFycy5jdXJ2aW5lc3MgPT09IDAgPyAyMCA6IDEyKSk7XG5cdH0sXG5cdCAgICBfZW1wdHlGdW5jID0gZnVuY3Rpb24gX2VtcHR5RnVuYyh2KSB7XG5cdCAgcmV0dXJuIHY7XG5cdH0sXG5cdCAgICBfbnVtRXhwID0gL1stK1xcLl0qXFxkK1xcLj8oPzplLXxlXFwrKT9cXGQqL2csXG5cdCAgICBfb3JpZ2luVG9Qb2ludCA9IGZ1bmN0aW9uIF9vcmlnaW5Ub1BvaW50KGVsZW1lbnQsIG9yaWdpbiwgcGFyZW50TWF0cml4KSB7XG5cdCAgdmFyIG0gPSBnZXRHbG9iYWxNYXRyaXgoZWxlbWVudCksXG5cdCAgICAgIHggPSAwLFxuXHQgICAgICB5ID0gMCxcblx0ICAgICAgc3ZnO1xuXG5cdCAgaWYgKChlbGVtZW50LnRhZ05hbWUgKyBcIlwiKS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiKSB7XG5cdCAgICBzdmcgPSBlbGVtZW50LnZpZXdCb3guYmFzZVZhbDtcblx0ICAgIHN2Zy53aWR0aCB8fCAoc3ZnID0ge1xuXHQgICAgICB3aWR0aDogK2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwid2lkdGhcIiksXG5cdCAgICAgIGhlaWdodDogK2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIpXG5cdCAgICB9KTtcblx0ICB9IGVsc2Uge1xuXHQgICAgc3ZnID0gb3JpZ2luICYmIGVsZW1lbnQuZ2V0QkJveCAmJiBlbGVtZW50LmdldEJCb3goKTtcblx0ICB9XG5cblx0ICBpZiAob3JpZ2luICYmIG9yaWdpbiAhPT0gXCJhdXRvXCIpIHtcblx0ICAgIHggPSBvcmlnaW4ucHVzaCA/IG9yaWdpblswXSAqIChzdmcgPyBzdmcud2lkdGggOiBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDApIDogb3JpZ2luLng7XG5cdCAgICB5ID0gb3JpZ2luLnB1c2ggPyBvcmlnaW5bMV0gKiAoc3ZnID8gc3ZnLmhlaWdodCA6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDApIDogb3JpZ2luLnk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHBhcmVudE1hdHJpeC5hcHBseSh4IHx8IHkgPyBtLmFwcGx5KHtcblx0ICAgIHg6IHgsXG5cdCAgICB5OiB5XG5cdCAgfSkgOiB7XG5cdCAgICB4OiBtLmUsXG5cdCAgICB5OiBtLmZcblx0ICB9KTtcblx0fSxcblx0ICAgIF9nZXRBbGlnbk1hdHJpeCA9IGZ1bmN0aW9uIF9nZXRBbGlnbk1hdHJpeChmcm9tRWxlbWVudCwgdG9FbGVtZW50LCBmcm9tT3JpZ2luLCB0b09yaWdpbikge1xuXHQgIHZhciBwYXJlbnRNYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZnJvbUVsZW1lbnQucGFyZW50Tm9kZSwgdHJ1ZSwgdHJ1ZSksXG5cdCAgICAgIG0gPSBwYXJlbnRNYXRyaXguY2xvbmUoKS5tdWx0aXBseShnZXRHbG9iYWxNYXRyaXgodG9FbGVtZW50KSksXG5cdCAgICAgIGZyb21Qb2ludCA9IF9vcmlnaW5Ub1BvaW50KGZyb21FbGVtZW50LCBmcm9tT3JpZ2luLCBwYXJlbnRNYXRyaXgpLFxuXHQgICAgICBfb3JpZ2luVG9Qb2ludDIgPSBfb3JpZ2luVG9Qb2ludCh0b0VsZW1lbnQsIHRvT3JpZ2luLCBwYXJlbnRNYXRyaXgpLFxuXHQgICAgICB4ID0gX29yaWdpblRvUG9pbnQyLngsXG5cdCAgICAgIHkgPSBfb3JpZ2luVG9Qb2ludDIueSxcblx0ICAgICAgcDtcblxuXHQgIG0uZSA9IG0uZiA9IDA7XG5cblx0ICBpZiAodG9PcmlnaW4gPT09IFwiYXV0b1wiICYmIHRvRWxlbWVudC5nZXRUb3RhbExlbmd0aCAmJiB0b0VsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInBhdGhcIikge1xuXHQgICAgcCA9IHRvRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkXCIpLm1hdGNoKF9udW1FeHApIHx8IFtdO1xuXHQgICAgcCA9IG0uYXBwbHkoe1xuXHQgICAgICB4OiArcFswXSxcblx0ICAgICAgeTogK3BbMV1cblx0ICAgIH0pO1xuXHQgICAgeCArPSBwLng7XG5cdCAgICB5ICs9IHAueTtcblx0ICB9XG5cblx0ICBpZiAocCkge1xuXHQgICAgcCA9IG0uYXBwbHkodG9FbGVtZW50LmdldEJCb3goKSk7XG5cdCAgICB4IC09IHAueDtcblx0ICAgIHkgLT0gcC55O1xuXHQgIH1cblxuXHQgIG0uZSA9IHggLSBmcm9tUG9pbnQueDtcblx0ICBtLmYgPSB5IC0gZnJvbVBvaW50Lnk7XG5cdCAgcmV0dXJuIG07XG5cdH0sXG5cdCAgICBfYWxpZ24gPSBmdW5jdGlvbiBfYWxpZ24ocmF3UGF0aCwgdGFyZ2V0LCBfcmVmKSB7XG5cdCAgdmFyIGFsaWduID0gX3JlZi5hbGlnbixcblx0ICAgICAgbWF0cml4ID0gX3JlZi5tYXRyaXgsXG5cdCAgICAgIG9mZnNldFggPSBfcmVmLm9mZnNldFgsXG5cdCAgICAgIG9mZnNldFkgPSBfcmVmLm9mZnNldFksXG5cdCAgICAgIGFsaWduT3JpZ2luID0gX3JlZi5hbGlnbk9yaWdpbjtcblxuXHQgIHZhciB4ID0gcmF3UGF0aFswXVswXSxcblx0ICAgICAgeSA9IHJhd1BhdGhbMF1bMV0sXG5cdCAgICAgIGN1clggPSBfZ2V0UHJvcE51bSh0YXJnZXQsIFwieFwiKSxcblx0ICAgICAgY3VyWSA9IF9nZXRQcm9wTnVtKHRhcmdldCwgXCJ5XCIpLFxuXHQgICAgICBhbGlnblRhcmdldCxcblx0ICAgICAgbSxcblx0ICAgICAgcDtcblxuXHQgIGlmICghcmF3UGF0aCB8fCAhcmF3UGF0aC5sZW5ndGgpIHtcblx0ICAgIHJldHVybiBnZXRSYXdQYXRoKFwiTTAsMEwwLDBcIik7XG5cdCAgfVxuXG5cdCAgaWYgKGFsaWduKSB7XG5cdCAgICBpZiAoYWxpZ24gPT09IFwic2VsZlwiIHx8IChhbGlnblRhcmdldCA9IF90b0FycmF5KGFsaWduKVswXSB8fCB0YXJnZXQpID09PSB0YXJnZXQpIHtcblx0ICAgICAgdHJhbnNmb3JtUmF3UGF0aChyYXdQYXRoLCAxLCAwLCAwLCAxLCBjdXJYIC0geCwgY3VyWSAtIHkpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKGFsaWduT3JpZ2luICYmIGFsaWduT3JpZ2luWzJdICE9PSBmYWxzZSkge1xuXHQgICAgICAgIGdzYXAuc2V0KHRhcmdldCwge1xuXHQgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBhbGlnbk9yaWdpblswXSAqIDEwMCArIFwiJSBcIiArIGFsaWduT3JpZ2luWzFdICogMTAwICsgXCIlXCJcblx0ICAgICAgICB9KTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBhbGlnbk9yaWdpbiA9IFtfZ2V0UHJvcE51bSh0YXJnZXQsIFwieFBlcmNlbnRcIikgLyAtMTAwLCBfZ2V0UHJvcE51bSh0YXJnZXQsIFwieVBlcmNlbnRcIikgLyAtMTAwXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIG0gPSBfZ2V0QWxpZ25NYXRyaXgodGFyZ2V0LCBhbGlnblRhcmdldCwgYWxpZ25PcmlnaW4sIFwiYXV0b1wiKTtcblx0ICAgICAgcCA9IG0uYXBwbHkoe1xuXHQgICAgICAgIHg6IHgsXG5cdCAgICAgICAgeTogeVxuXHQgICAgICB9KTtcblx0ICAgICAgdHJhbnNmb3JtUmF3UGF0aChyYXdQYXRoLCBtLmEsIG0uYiwgbS5jLCBtLmQsIGN1clggKyBtLmUgLSAocC54IC0gbS5lKSwgY3VyWSArIG0uZiAtIChwLnkgLSBtLmYpKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAobWF0cml4KSB7XG5cdCAgICB0cmFuc2Zvcm1SYXdQYXRoKHJhd1BhdGgsIG1hdHJpeC5hLCBtYXRyaXguYiwgbWF0cml4LmMsIG1hdHJpeC5kLCBtYXRyaXguZSwgbWF0cml4LmYpO1xuXHQgIH0gZWxzZSBpZiAob2Zmc2V0WCB8fCBvZmZzZXRZKSB7XG5cdCAgICB0cmFuc2Zvcm1SYXdQYXRoKHJhd1BhdGgsIDEsIDAsIDAsIDEsIG9mZnNldFggfHwgMCwgb2Zmc2V0WSB8fCAwKTtcblx0ICB9XG5cblx0ICByZXR1cm4gcmF3UGF0aDtcblx0fSxcblx0ICAgIF9hZGREaW1lbnNpb25hbFByb3BUd2VlbiA9IGZ1bmN0aW9uIF9hZGREaW1lbnNpb25hbFByb3BUd2VlbihwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIHJhd1BhdGgsIHBhdGhQcm9wZXJ0eSwgZm9yY2VVbml0KSB7XG5cdCAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwLFxuXHQgICAgICBoYXJuZXNzID0gY2FjaGUuaGFybmVzcyxcblx0ICAgICAgYWxpYXMgPSBoYXJuZXNzICYmIGhhcm5lc3MuYWxpYXNlcyAmJiBoYXJuZXNzLmFsaWFzZXNbcHJvcGVydHldLFxuXHQgICAgICBwcm9wID0gYWxpYXMgJiYgYWxpYXMuaW5kZXhPZihcIixcIikgPCAwID8gYWxpYXMgOiBwcm9wZXJ0eSxcblx0ICAgICAgcHQgPSBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3AsIDAsIDAsIF9lbXB0eUZ1bmMsIDAsIGNhY2hlLnNldCh0YXJnZXQsIHByb3AsIHBsdWdpbikpO1xuXHQgIHB0LnUgPSBfZ2V0VW5pdChjYWNoZS5nZXQodGFyZ2V0LCBwcm9wLCBmb3JjZVVuaXQpKSB8fCAwO1xuXHQgIHB0LnBhdGggPSByYXdQYXRoO1xuXHQgIHB0LnBwID0gcGF0aFByb3BlcnR5O1xuXG5cdCAgcGx1Z2luLl9wcm9wcy5wdXNoKHByb3ApO1xuXHR9LFxuXHQgICAgX3NsaWNlTW9kaWZpZXIgPSBmdW5jdGlvbiBfc2xpY2VNb2RpZmllcihzdGFydCwgZW5kKSB7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIChyYXdQYXRoKSB7XG5cdCAgICByZXR1cm4gc3RhcnQgfHwgZW5kICE9PSAxID8gc2xpY2VSYXdQYXRoKHJhd1BhdGgsIHN0YXJ0LCBlbmQpIDogcmF3UGF0aDtcblx0ICB9O1xuXHR9O1xuXG5cdHZhciBNb3Rpb25QYXRoUGx1Z2luID0ge1xuXHQgIHZlcnNpb246IFwiMy4xMi41XCIsXG5cdCAgbmFtZTogXCJtb3Rpb25QYXRoXCIsXG5cdCAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvcmUsIFBsdWdpbiwgcHJvcFR3ZWVuKSB7XG5cdCAgICBnc2FwID0gY29yZTtcblx0ICAgIF9nZXRVbml0ID0gZ3NhcC51dGlscy5nZXRVbml0O1xuXHQgICAgX3RvQXJyYXkgPSBnc2FwLnV0aWxzLnRvQXJyYXk7XG5cdCAgICBfZ2V0U3R5bGVTYXZlciA9IGdzYXAuY29yZS5nZXRTdHlsZVNhdmVyO1xuXG5cdCAgICBfcmV2ZXJ0aW5nID0gZ3NhcC5jb3JlLnJldmVydGluZyB8fCBmdW5jdGlvbiAoKSB7fTtcblxuXHQgICAgUHJvcFR3ZWVuID0gcHJvcFR3ZWVuO1xuXHQgIH0sXG5cdCAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuKSB7XG5cdCAgICBpZiAoIWdzYXApIHtcblx0ICAgICAgY29uc29sZS53YXJuKFwiUGxlYXNlIGdzYXAucmVnaXN0ZXJQbHVnaW4oTW90aW9uUGF0aFBsdWdpbilcIik7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKCEodHlwZW9mIHZhcnMgPT09IFwib2JqZWN0XCIgJiYgIXZhcnMuc3R5bGUpIHx8ICF2YXJzLnBhdGgpIHtcblx0ICAgICAgdmFycyA9IHtcblx0ICAgICAgICBwYXRoOiB2YXJzXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIHZhciByYXdQYXRocyA9IFtdLFxuXHQgICAgICAgIF92YXJzID0gdmFycyxcblx0ICAgICAgICBwYXRoID0gX3ZhcnMucGF0aCxcblx0ICAgICAgICBhdXRvUm90YXRlID0gX3ZhcnMuYXV0b1JvdGF0ZSxcblx0ICAgICAgICB1bml0WCA9IF92YXJzLnVuaXRYLFxuXHQgICAgICAgIHVuaXRZID0gX3ZhcnMudW5pdFksXG5cdCAgICAgICAgeCA9IF92YXJzLngsXG5cdCAgICAgICAgeSA9IF92YXJzLnksXG5cdCAgICAgICAgZmlyc3RPYmogPSBwYXRoWzBdLFxuXHQgICAgICAgIHNsaWNlciA9IF9zbGljZU1vZGlmaWVyKHZhcnMuc3RhcnQsIFwiZW5kXCIgaW4gdmFycyA/IHZhcnMuZW5kIDogMSksXG5cdCAgICAgICAgcmF3UGF0aCxcblx0ICAgICAgICBwO1xuXG5cdCAgICB0aGlzLnJhd1BhdGhzID0gcmF3UGF0aHM7XG5cdCAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcblx0ICAgIHRoaXMudHdlZW4gPSB0d2Vlbjtcblx0ICAgIHRoaXMuc3R5bGVzID0gX2dldFN0eWxlU2F2ZXIgJiYgX2dldFN0eWxlU2F2ZXIodGFyZ2V0LCBcInRyYW5zZm9ybVwiKTtcblxuXHQgICAgaWYgKHRoaXMucm90YXRlID0gYXV0b1JvdGF0ZSB8fCBhdXRvUm90YXRlID09PSAwKSB7XG5cdCAgICAgIHRoaXMuck9mZnNldCA9IHBhcnNlRmxvYXQoYXV0b1JvdGF0ZSkgfHwgMDtcblx0ICAgICAgdGhpcy5yYWRpYW5zID0gISF2YXJzLnVzZVJhZGlhbnM7XG5cdCAgICAgIHRoaXMuclByb3AgPSB2YXJzLnJvdGF0aW9uIHx8IFwicm90YXRpb25cIjtcblx0ICAgICAgdGhpcy5yU2V0ID0gdGFyZ2V0Ll9nc2FwLnNldCh0YXJnZXQsIHRoaXMuclByb3AsIHRoaXMpO1xuXHQgICAgICB0aGlzLnJ1ID0gX2dldFVuaXQodGFyZ2V0Ll9nc2FwLmdldCh0YXJnZXQsIHRoaXMuclByb3ApKSB8fCAwO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSAmJiAhKFwiY2xvc2VkXCIgaW4gcGF0aCkgJiYgdHlwZW9mIGZpcnN0T2JqICE9PSBcIm51bWJlclwiKSB7XG5cdCAgICAgIGZvciAocCBpbiBmaXJzdE9iaikge1xuXHQgICAgICAgIGlmICgheCAmJiB+X3hQcm9wcy5pbmRleE9mKHApKSB7XG5cdCAgICAgICAgICB4ID0gcDtcblx0ICAgICAgICB9IGVsc2UgaWYgKCF5ICYmIH5feVByb3BzLmluZGV4T2YocCkpIHtcblx0ICAgICAgICAgIHkgPSBwO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh4ICYmIHkpIHtcblx0ICAgICAgICByYXdQYXRocy5wdXNoKF9zZWdtZW50VG9SYXdQYXRoKHRoaXMsIF9wb3B1bGF0ZVNlZ21lbnRGcm9tQXJyYXkoX3BvcHVsYXRlU2VnbWVudEZyb21BcnJheShbXSwgcGF0aCwgeCwgMCksIHBhdGgsIHksIDEpLCB0YXJnZXQsIHgsIHksIHNsaWNlciwgdmFycywgdW5pdFggfHwgX2dldFVuaXQocGF0aFswXVt4XSksIHVuaXRZIHx8IF9nZXRVbml0KHBhdGhbMF1beV0pKSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgeCA9IHkgPSAwO1xuXHQgICAgICB9XG5cblx0ICAgICAgZm9yIChwIGluIGZpcnN0T2JqKSB7XG5cdCAgICAgICAgcCAhPT0geCAmJiBwICE9PSB5ICYmIHJhd1BhdGhzLnB1c2goX3NlZ21lbnRUb1Jhd1BhdGgodGhpcywgX3BvcHVsYXRlU2VnbWVudEZyb21BcnJheShbXSwgcGF0aCwgcCwgMiksIHRhcmdldCwgcCwgMCwgc2xpY2VyLCB2YXJzLCBfZ2V0VW5pdChwYXRoWzBdW3BdKSkpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByYXdQYXRoID0gc2xpY2VyKF9hbGlnbihnZXRSYXdQYXRoKHZhcnMucGF0aCksIHRhcmdldCwgdmFycykpO1xuXHQgICAgICBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMocmF3UGF0aCwgdmFycy5yZXNvbHV0aW9uKTtcblx0ICAgICAgcmF3UGF0aHMucHVzaChyYXdQYXRoKTtcblxuXHQgICAgICBfYWRkRGltZW5zaW9uYWxQcm9wVHdlZW4odGhpcywgdGFyZ2V0LCB2YXJzLnggfHwgXCJ4XCIsIHJhd1BhdGgsIFwieFwiLCB2YXJzLnVuaXRYIHx8IFwicHhcIik7XG5cblx0ICAgICAgX2FkZERpbWVuc2lvbmFsUHJvcFR3ZWVuKHRoaXMsIHRhcmdldCwgdmFycy55IHx8IFwieVwiLCByYXdQYXRoLCBcInlcIiwgdmFycy51bml0WSB8fCBcInB4XCIpO1xuXHQgICAgfVxuXHQgIH0sXG5cdCAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocmF0aW8sIGRhdGEpIHtcblx0ICAgIHZhciByYXdQYXRocyA9IGRhdGEucmF3UGF0aHMsXG5cdCAgICAgICAgaSA9IHJhd1BhdGhzLmxlbmd0aCxcblx0ICAgICAgICBwdCA9IGRhdGEuX3B0O1xuXG5cdCAgICBpZiAoZGF0YS50d2Vlbi5fdGltZSB8fCAhX3JldmVydGluZygpKSB7XG5cdCAgICAgIGlmIChyYXRpbyA+IDEpIHtcblx0ICAgICAgICByYXRpbyA9IDE7XG5cdCAgICAgIH0gZWxzZSBpZiAocmF0aW8gPCAwKSB7XG5cdCAgICAgICAgcmF0aW8gPSAwO1xuXHQgICAgICB9XG5cblx0ICAgICAgd2hpbGUgKGktLSkge1xuXHQgICAgICAgIGdldFBvc2l0aW9uT25QYXRoKHJhd1BhdGhzW2ldLCByYXRpbywgIWkgJiYgZGF0YS5yb3RhdGUsIHJhd1BhdGhzW2ldKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHdoaWxlIChwdCkge1xuXHQgICAgICAgIHB0LnNldChwdC50LCBwdC5wLCBwdC5wYXRoW3B0LnBwXSArIHB0LnUsIHB0LmQsIHJhdGlvKTtcblx0ICAgICAgICBwdCA9IHB0Ll9uZXh0O1xuXHQgICAgICB9XG5cblx0ICAgICAgZGF0YS5yb3RhdGUgJiYgZGF0YS5yU2V0KGRhdGEudGFyZ2V0LCBkYXRhLnJQcm9wLCByYXdQYXRoc1swXS5hbmdsZSAqIChkYXRhLnJhZGlhbnMgPyBfREVHMlJBRCQxIDogMSkgKyBkYXRhLnJPZmZzZXQgKyBkYXRhLnJ1LCBkYXRhLCByYXRpbyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBkYXRhLnN0eWxlcy5yZXZlcnQoKTtcblx0ICAgIH1cblx0ICB9LFxuXHQgIGdldExlbmd0aDogZnVuY3Rpb24gZ2V0TGVuZ3RoKHBhdGgpIHtcblx0ICAgIHJldHVybiBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMoZ2V0UmF3UGF0aChwYXRoKSkudG90YWxMZW5ndGg7XG5cdCAgfSxcblx0ICBzbGljZVJhd1BhdGg6IHNsaWNlUmF3UGF0aCxcblx0ICBnZXRSYXdQYXRoOiBnZXRSYXdQYXRoLFxuXHQgIHBvaW50c1RvU2VnbWVudDogcG9pbnRzVG9TZWdtZW50LFxuXHQgIHN0cmluZ1RvUmF3UGF0aDogc3RyaW5nVG9SYXdQYXRoLFxuXHQgIHJhd1BhdGhUb1N0cmluZzogcmF3UGF0aFRvU3RyaW5nLFxuXHQgIHRyYW5zZm9ybVJhd1BhdGg6IHRyYW5zZm9ybVJhd1BhdGgsXG5cdCAgZ2V0R2xvYmFsTWF0cml4OiBnZXRHbG9iYWxNYXRyaXgsXG5cdCAgZ2V0UG9zaXRpb25PblBhdGg6IGdldFBvc2l0aW9uT25QYXRoLFxuXHQgIGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50czogY2FjaGVSYXdQYXRoTWVhc3VyZW1lbnRzLFxuXHQgIGNvbnZlcnRUb1BhdGg6IGZ1bmN0aW9uIGNvbnZlcnRUb1BhdGgkMSh0YXJnZXRzLCBzd2FwKSB7XG5cdCAgICByZXR1cm4gX3RvQXJyYXkodGFyZ2V0cykubWFwKGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0ICAgICAgcmV0dXJuIGNvbnZlcnRUb1BhdGgodGFyZ2V0LCBzd2FwICE9PSBmYWxzZSk7XG5cdCAgICB9KTtcblx0ICB9LFxuXHQgIGNvbnZlcnRDb29yZGluYXRlczogZnVuY3Rpb24gY29udmVydENvb3JkaW5hdGVzKGZyb21FbGVtZW50LCB0b0VsZW1lbnQsIHBvaW50KSB7XG5cdCAgICB2YXIgbSA9IGdldEdsb2JhbE1hdHJpeCh0b0VsZW1lbnQsIHRydWUsIHRydWUpLm11bHRpcGx5KGdldEdsb2JhbE1hdHJpeChmcm9tRWxlbWVudCkpO1xuXHQgICAgcmV0dXJuIHBvaW50ID8gbS5hcHBseShwb2ludCkgOiBtO1xuXHQgIH0sXG5cdCAgZ2V0QWxpZ25NYXRyaXg6IF9nZXRBbGlnbk1hdHJpeCxcblx0ICBnZXRSZWxhdGl2ZVBvc2l0aW9uOiBmdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKGZyb21FbGVtZW50LCB0b0VsZW1lbnQsIGZyb21PcmlnaW4sIHRvT3JpZ2luKSB7XG5cdCAgICB2YXIgbSA9IF9nZXRBbGlnbk1hdHJpeChmcm9tRWxlbWVudCwgdG9FbGVtZW50LCBmcm9tT3JpZ2luLCB0b09yaWdpbik7XG5cblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHg6IG0uZSxcblx0ICAgICAgeTogbS5mXG5cdCAgICB9O1xuXHQgIH0sXG5cdCAgYXJyYXlUb1Jhd1BhdGg6IGZ1bmN0aW9uIGFycmF5VG9SYXdQYXRoKHZhbHVlLCB2YXJzKSB7XG5cdCAgICB2YXJzID0gdmFycyB8fCB7fTtcblxuXHQgICAgdmFyIHNlZ21lbnQgPSBfcG9wdWxhdGVTZWdtZW50RnJvbUFycmF5KF9wb3B1bGF0ZVNlZ21lbnRGcm9tQXJyYXkoW10sIHZhbHVlLCB2YXJzLnggfHwgXCJ4XCIsIDApLCB2YWx1ZSwgdmFycy55IHx8IFwieVwiLCAxKTtcblxuXHQgICAgdmFycy5yZWxhdGl2ZSAmJiBfcmVsYXRpdml6ZShzZWdtZW50KTtcblx0ICAgIHJldHVybiBbdmFycy50eXBlID09PSBcImN1YmljXCIgPyBzZWdtZW50IDogcG9pbnRzVG9TZWdtZW50KHNlZ21lbnQsIHZhcnMuY3VydmluZXNzKV07XG5cdCAgfVxuXHR9O1xuXHRfZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oTW90aW9uUGF0aFBsdWdpbik7XG5cblx0ZXhwb3J0cy5Nb3Rpb25QYXRoUGx1Z2luID0gTW90aW9uUGF0aFBsdWdpbjtcblx0ZXhwb3J0cy5kZWZhdWx0ID0gTW90aW9uUGF0aFBsdWdpbjtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/gsap/dist/MotionPathPlugin.js\n"));

/***/ }),

/***/ "./components/FootstepsAnimation.tsx":
/*!*******************************************!*\
  !*** ./components/FootstepsAnimation.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gsap */ \"./node_modules/gsap/index.js\");\n/* harmony import */ var gsap_dist_MotionPathPlugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gsap/dist/MotionPathPlugin */ \"./node_modules/gsap/dist/MotionPathPlugin.js\");\n/* harmony import */ var gsap_dist_MotionPathPlugin__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(gsap_dist_MotionPathPlugin__WEBPACK_IMPORTED_MODULE_3__);\n\nvar _s = $RefreshSig$();\n\n\n\ngsap__WEBPACK_IMPORTED_MODULE_2__[\"default\"].registerPlugin(gsap_dist_MotionPathPlugin__WEBPACK_IMPORTED_MODULE_3__.MotionPathPlugin);\nconst FootstepsAnimation = ()=>{\n    _s();\n    const footstepRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const ghostTrailRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!footstepRef.current) return;\n        // Define the curved path\n        const path = {\n            type: \"cubic\",\n            path: [\n                {\n                    x: 0,\n                    y: 0\n                },\n                {\n                    x: 100,\n                    y: -50\n                },\n                {\n                    x: 200,\n                    y: -30\n                },\n                {\n                    x: 300,\n                    y: -60\n                },\n                {\n                    x: 400,\n                    y: -20\n                } // Tech Innovation\n            ],\n            autoRotate: true\n        };\n        // Create footstep animation\n        gsap__WEBPACK_IMPORTED_MODULE_2__[\"default\"].to(footstepRef.current, {\n            duration: 5,\n            repeat: -1,\n            ease: \"none\",\n            motionPath: path,\n            onUpdate: createGhostTrail\n        });\n    }, []);\n    const createGhostTrail = ()=>{\n        if (!footstepRef.current || !ghostTrailRef.current) return;\n        const ghost = footstepRef.current.cloneNode(true);\n        ghost.style.position = \"absolute\";\n        ghost.style.opacity = \"0.6\";\n        ghostTrailRef.current.appendChild(ghost);\n        gsap__WEBPACK_IMPORTED_MODULE_2__[\"default\"].to(ghost, {\n            duration: 1,\n            opacity: 0,\n            onComplete: ()=>ghost.remove()\n        });\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"fixed inset-0 pointer-events-none\",\n        style: {\n            zIndex: 50\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            ref: ghostTrailRef,\n            className: \"ghost-trail-container\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: footstepRef,\n                className: \"footstep\",\n                style: {\n                    width: \"30px\",\n                    height: \"30px\",\n                    position: \"absolute\",\n                    backgroundImage: \"url(/footprint.svg)\",\n                    backgroundSize: \"contain\",\n                    backgroundRepeat: \"no-repeat\"\n                }\n            }, void 0, false, {\n                fileName: \"/Users/fausto/coding_2024/dell_presentation/components/FootstepsAnimation.tsx\",\n                lineNumber: 55,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"/Users/fausto/coding_2024/dell_presentation/components/FootstepsAnimation.tsx\",\n            lineNumber: 54,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/fausto/coding_2024/dell_presentation/components/FootstepsAnimation.tsx\",\n        lineNumber: 53,\n        columnNumber: 5\n    }, undefined);\n};\n_s(FootstepsAnimation, \"gyLvw1zCpdr2iiT/M2hPv++tAJA=\");\n_c = FootstepsAnimation;\n/* harmony default export */ __webpack_exports__[\"default\"] = (FootstepsAnimation);\nvar _c;\n$RefreshReg$(_c, \"FootstepsAnimation\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0Zvb3RzdGVwc0FuaW1hdGlvbi50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFpRDtBQUN6QjtBQUNzQztBQUU5REcsMkRBQW1CLENBQUNDLHdFQUFnQkE7QUFFcEMsTUFBTUUscUJBQXFCOztJQUN6QixNQUFNQyxjQUFjTCw2Q0FBTUEsQ0FBaUI7SUFDM0MsTUFBTU0sZ0JBQWdCTiw2Q0FBTUEsQ0FBaUI7SUFFN0NELGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxDQUFDTSxZQUFZRSxPQUFPLEVBQUU7UUFFMUIseUJBQXlCO1FBQ3pCLE1BQU1DLE9BQU87WUFDWEMsTUFBTTtZQUNORCxNQUFNO2dCQUNKO29CQUFFRSxHQUFHO29CQUFHQyxHQUFHO2dCQUFFO2dCQUNiO29CQUFFRCxHQUFHO29CQUFLQyxHQUFHLENBQUM7Z0JBQUc7Z0JBQ2pCO29CQUFFRCxHQUFHO29CQUFLQyxHQUFHLENBQUM7Z0JBQUc7Z0JBQ2pCO29CQUFFRCxHQUFHO29CQUFLQyxHQUFHLENBQUM7Z0JBQUc7Z0JBQ2pCO29CQUFFRCxHQUFHO29CQUFLQyxHQUFHLENBQUM7Z0JBQUcsRUFBUyxrQkFBa0I7YUFDN0M7WUFDREMsWUFBWTtRQUNkO1FBRUEsNEJBQTRCO1FBQzVCWCwrQ0FBTyxDQUFDSSxZQUFZRSxPQUFPLEVBQUU7WUFDM0JPLFVBQVU7WUFDVkMsUUFBUSxDQUFDO1lBQ1RDLE1BQU07WUFDTkMsWUFBWVQ7WUFDWlUsVUFBVUM7UUFDWjtJQUNGLEdBQUcsRUFBRTtJQUVMLE1BQU1BLG1CQUFtQjtRQUN2QixJQUFJLENBQUNkLFlBQVlFLE9BQU8sSUFBSSxDQUFDRCxjQUFjQyxPQUFPLEVBQUU7UUFFcEQsTUFBTWEsUUFBUWYsWUFBWUUsT0FBTyxDQUFDYyxTQUFTLENBQUM7UUFDNUNELE1BQU1FLEtBQUssQ0FBQ0MsUUFBUSxHQUFHO1FBQ3ZCSCxNQUFNRSxLQUFLLENBQUNFLE9BQU8sR0FBRztRQUN0QmxCLGNBQWNDLE9BQU8sQ0FBQ2tCLFdBQVcsQ0FBQ0w7UUFFbENuQiwrQ0FBTyxDQUFDbUIsT0FBTztZQUNiTixVQUFVO1lBQ1ZVLFNBQVM7WUFDVEUsWUFBWSxJQUFNTixNQUFNTyxNQUFNO1FBQ2hDO0lBQ0Y7SUFFQSxxQkFDRSw4REFBQ0M7UUFBSUMsV0FBVTtRQUFvQ1AsT0FBTztZQUFFUSxRQUFRO1FBQUc7a0JBQ3JFLDRFQUFDRjtZQUFJRyxLQUFLekI7WUFBZXVCLFdBQVU7c0JBQ2pDLDRFQUFDRDtnQkFDQ0csS0FBSzFCO2dCQUNMd0IsV0FBVTtnQkFDVlAsT0FBTztvQkFDTFUsT0FBTztvQkFDUEMsUUFBUTtvQkFDUlYsVUFBVTtvQkFDVlcsaUJBQWlCO29CQUNqQkMsZ0JBQWdCO29CQUNoQkMsa0JBQWtCO2dCQUNwQjs7Ozs7Ozs7Ozs7Ozs7OztBQUtWO0dBL0RNaEM7S0FBQUE7QUFpRU4sK0RBQWVBLGtCQUFrQkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0Zvb3RzdGVwc0FuaW1hdGlvbi50c3g/ZDg0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgZ3NhcCBmcm9tICdnc2FwJztcbmltcG9ydCB7IE1vdGlvblBhdGhQbHVnaW4gfSBmcm9tICdnc2FwL2Rpc3QvTW90aW9uUGF0aFBsdWdpbic7XG5cbmdzYXAucmVnaXN0ZXJQbHVnaW4oTW90aW9uUGF0aFBsdWdpbik7XG5cbmNvbnN0IEZvb3RzdGVwc0FuaW1hdGlvbiA9ICgpID0+IHtcbiAgY29uc3QgZm9vdHN0ZXBSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBnaG9zdFRyYWlsUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZm9vdHN0ZXBSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgLy8gRGVmaW5lIHRoZSBjdXJ2ZWQgcGF0aFxuICAgIGNvbnN0IHBhdGggPSB7XG4gICAgICB0eXBlOiBcImN1YmljXCIsXG4gICAgICBwYXRoOiBbXG4gICAgICAgIHsgeDogMCwgeTogMCB9LCAgICAgICAgICAgLy8gU3RhcnQgYXQgQWNhZGVtaWMgRm91bmRhdGlvblxuICAgICAgICB7IHg6IDEwMCwgeTogLTUwIH0sICAgICAgIC8vIENvbnRyb2wgcG9pbnQgMVxuICAgICAgICB7IHg6IDIwMCwgeTogLTMwIH0sICAgICAgIC8vIEJ1c2luZXNzIExlYWRlcnNoaXBcbiAgICAgICAgeyB4OiAzMDAsIHk6IC02MCB9LCAgICAgICAvLyBDb250cm9sIHBvaW50IDJcbiAgICAgICAgeyB4OiA0MDAsIHk6IC0yMCB9ICAgICAgICAvLyBUZWNoIElubm92YXRpb25cbiAgICAgIF0sXG4gICAgICBhdXRvUm90YXRlOiB0cnVlXG4gICAgfTtcblxuICAgIC8vIENyZWF0ZSBmb290c3RlcCBhbmltYXRpb25cbiAgICBnc2FwLnRvKGZvb3RzdGVwUmVmLmN1cnJlbnQsIHtcbiAgICAgIGR1cmF0aW9uOiA1LFxuICAgICAgcmVwZWF0OiAtMSxcbiAgICAgIGVhc2U6IFwibm9uZVwiLFxuICAgICAgbW90aW9uUGF0aDogcGF0aCxcbiAgICAgIG9uVXBkYXRlOiBjcmVhdGVHaG9zdFRyYWlsXG4gICAgfSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBjcmVhdGVHaG9zdFRyYWlsID0gKCkgPT4ge1xuICAgIGlmICghZm9vdHN0ZXBSZWYuY3VycmVudCB8fCAhZ2hvc3RUcmFpbFJlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICBjb25zdCBnaG9zdCA9IGZvb3RzdGVwUmVmLmN1cnJlbnQuY2xvbmVOb2RlKHRydWUpIGFzIEhUTUxEaXZFbGVtZW50O1xuICAgIGdob3N0LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBnaG9zdC5zdHlsZS5vcGFjaXR5ID0gJzAuNic7XG4gICAgZ2hvc3RUcmFpbFJlZi5jdXJyZW50LmFwcGVuZENoaWxkKGdob3N0KTtcblxuICAgIGdzYXAudG8oZ2hvc3QsIHtcbiAgICAgIGR1cmF0aW9uOiAxLFxuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IGdob3N0LnJlbW92ZSgpXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImZpeGVkIGluc2V0LTAgcG9pbnRlci1ldmVudHMtbm9uZVwiIHN0eWxlPXt7IHpJbmRleDogNTAgfX0+XG4gICAgICA8ZGl2IHJlZj17Z2hvc3RUcmFpbFJlZn0gY2xhc3NOYW1lPVwiZ2hvc3QtdHJhaWwtY29udGFpbmVyXCI+XG4gICAgICAgIDxkaXYgXG4gICAgICAgICAgcmVmPXtmb290c3RlcFJlZn1cbiAgICAgICAgICBjbGFzc05hbWU9XCJmb290c3RlcFwiXG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIHdpZHRoOiAnMzBweCcsXG4gICAgICAgICAgICBoZWlnaHQ6ICczMHB4JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlOiAndXJsKC9mb290cHJpbnQuc3ZnKScsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2l6ZTogJ2NvbnRhaW4nLFxuICAgICAgICAgICAgYmFja2dyb3VuZFJlcGVhdDogJ25vLXJlcGVhdCdcbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBGb290c3RlcHNBbmltYXRpb247ICJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsImdzYXAiLCJNb3Rpb25QYXRoUGx1Z2luIiwicmVnaXN0ZXJQbHVnaW4iLCJGb290c3RlcHNBbmltYXRpb24iLCJmb290c3RlcFJlZiIsImdob3N0VHJhaWxSZWYiLCJjdXJyZW50IiwicGF0aCIsInR5cGUiLCJ4IiwieSIsImF1dG9Sb3RhdGUiLCJ0byIsImR1cmF0aW9uIiwicmVwZWF0IiwiZWFzZSIsIm1vdGlvblBhdGgiLCJvblVwZGF0ZSIsImNyZWF0ZUdob3N0VHJhaWwiLCJnaG9zdCIsImNsb25lTm9kZSIsInN0eWxlIiwicG9zaXRpb24iLCJvcGFjaXR5IiwiYXBwZW5kQ2hpbGQiLCJvbkNvbXBsZXRlIiwicmVtb3ZlIiwiZGl2IiwiY2xhc3NOYW1lIiwiekluZGV4IiwicmVmIiwid2lkdGgiLCJoZWlnaHQiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJiYWNrZ3JvdW5kU2l6ZSIsImJhY2tncm91bmRSZXBlYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/FootstepsAnimation.tsx\n"));

/***/ })

});